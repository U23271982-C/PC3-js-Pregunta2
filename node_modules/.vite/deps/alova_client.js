import {
  Method,
  globalConfigMap,
  hitCacheBySource,
  invalidateCache,
  promiseStatesHook,
  queryCache,
  setCache
} from "./chunk-3GRCPVGW.js";
import {
  $self,
  AlovaError,
  FrameworkReadableState,
  FrameworkState,
  JSONParse,
  JSONStringify,
  MEMORY,
  ObjectCls,
  PromiseCls,
  RegExpCls,
  buildCompletedURL,
  buildNamespacedCacheKey,
  clearTimeoutTimer,
  createAssert,
  createAsyncQueue,
  createEventManager,
  createSyncOnceRunner,
  decorateEvent,
  defineProperty,
  delayWithBackoff,
  deleteAttr,
  falseValue,
  filterItem,
  forEach,
  getConfig,
  getContext,
  getHandlerMethod,
  getLocalCacheConfigParam,
  getMethodInternalKey,
  getOptions,
  getTime,
  globalToString,
  includes,
  injectReferingObject,
  instanceOf,
  isArray,
  isFn,
  isNumber,
  isObject,
  isPlainObject,
  isSpecialRequestBody,
  isString,
  len,
  mapItem,
  newInstance,
  noop,
  nullValue,
  objAssign,
  objectKeys,
  objectValues,
  omit,
  promiseAll,
  promiseCatch,
  promiseFinally,
  promiseReject,
  promiseResolve,
  promiseThen,
  pushItem,
  regexpTest,
  setTimeoutFn,
  shift,
  sloughConfig,
  splice,
  trueValue,
  undefinedValue,
  usePromise,
  uuid,
  valueObject,
  walkObject
} from "./chunk-PH77QZA5.js";
import "./chunk-G3PMV62Z.js";

// node_modules/alova/dist/clienthook/index.esm.js
var defaultVisitorMeta = {
  authRole: null
};
var defaultLoginMeta = {
  authRole: "login"
};
var defaultLogoutMeta = {
  authRole: "logout"
};
var defaultRefreshTokenMeta = {
  authRole: "refreshToken"
};
var checkMethodRole = ({ meta }, metaMatches) => {
  if (isPlainObject(meta)) {
    for (const key in meta) {
      if (Object.prototype.hasOwnProperty.call(meta, key)) {
        const matchedMetaItem = metaMatches[key];
        if (instanceOf(matchedMetaItem, RegExp) ? matchedMetaItem.test(meta[key]) : meta[key] === matchedMetaItem) {
          return trueValue;
        }
      }
    }
  }
  return falseValue;
};
var waitForTokenRefreshed = (method, waitingList) => newInstance(PromiseCls, (resolve) => {
  pushItem(waitingList, {
    method,
    resolve
  });
});
var callHandlerIfMatchesMeta = (method, authorizationInterceptor, defaultMeta, response) => {
  if (checkMethodRole(method, (authorizationInterceptor === null || authorizationInterceptor === void 0 ? void 0 : authorizationInterceptor.metaMatches) || defaultMeta)) {
    const handler = isFn(authorizationInterceptor) ? authorizationInterceptor : isPlainObject(authorizationInterceptor) && isFn(authorizationInterceptor.handler) ? authorizationInterceptor.handler : noop;
    return handler(response, method);
  }
};
var refreshTokenIfExpired = async (method, waitingList, updateRefreshStatus, handlerParams, refreshToken, tokenRefreshing) => {
  const fromResponse = len(handlerParams) >= 2;
  let isExpired = refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.isExpired(...handlerParams);
  if (instanceOf(isExpired, PromiseCls)) {
    isExpired = await isExpired;
  }
  if (isExpired) {
    try {
      let intentToRefreshToken = trueValue;
      if (fromResponse && tokenRefreshing) {
        intentToRefreshToken = falseValue;
        await waitForTokenRefreshed(method, waitingList);
      }
      if (intentToRefreshToken) {
        updateRefreshStatus(trueValue);
        await (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.handler(...handlerParams));
        updateRefreshStatus(falseValue);
        forEach(waitingList, ({ resolve }) => resolve());
      }
      if (fromResponse) {
        const { config } = method;
        const methodTransformData = config.transform;
        config.transform = undefinedValue;
        const resentData = await method;
        config.transform = methodTransformData;
        return resentData;
      }
    } finally {
      updateRefreshStatus(falseValue);
      splice(waitingList, 0, len(waitingList));
    }
  }
};
var onResponded2Record = (onRespondedHandlers) => {
  let successHandler = undefinedValue;
  let errorHandler = undefinedValue;
  let onCompleteHandler = undefinedValue;
  if (isFn(onRespondedHandlers)) {
    successHandler = onRespondedHandlers;
  } else if (isPlainObject(onRespondedHandlers)) {
    const { onSuccess, onError, onComplete } = onRespondedHandlers;
    successHandler = isFn(onSuccess) ? onSuccess : successHandler;
    errorHandler = isFn(onError) ? onError : errorHandler;
    onCompleteHandler = isFn(onComplete) ? onComplete : onCompleteHandler;
  }
  return {
    onSuccess: successHandler,
    onError: errorHandler,
    onComplete: onCompleteHandler
  };
};
var createClientTokenAuthentication = ({ visitorMeta, login, logout, refreshToken, assignToken = noop }) => {
  let tokenRefreshing = falseValue;
  const waitingList = [];
  const onAuthRequired = (onBeforeRequest) => async (method) => {
    const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);
    const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);
    if (!isVisitorRole && !isLoginRole && !checkMethodRole(method, (refreshToken === null || refreshToken === void 0 ? void 0 : refreshToken.metaMatches) || defaultRefreshTokenMeta)) {
      if (tokenRefreshing) {
        await waitForTokenRefreshed(method, waitingList);
      }
      await refreshTokenIfExpired(method, waitingList, (refreshing) => {
        tokenRefreshing = refreshing;
      }, [method], refreshToken);
    }
    if (!isVisitorRole && !isLoginRole) {
      await assignToken(method);
    }
    return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);
  };
  const onResponseRefreshToken = (originalResponded) => {
    const respondedRecord = onResponded2Record(originalResponded);
    return {
      ...respondedRecord,
      onSuccess: async (response, method) => {
        await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);
        await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);
        return (respondedRecord.onSuccess || $self)(response, method);
      }
    };
  };
  return {
    waitingList,
    onAuthRequired,
    onResponseRefreshToken
  };
};
var createServerTokenAuthentication = ({ visitorMeta, login, logout, refreshTokenOnSuccess, refreshTokenOnError, assignToken = noop }) => {
  let tokenRefreshing = falseValue;
  const waitingList = [];
  const onAuthRequired = (onBeforeRequest) => async (method) => {
    const isVisitorRole = checkMethodRole(method, visitorMeta || defaultVisitorMeta);
    const isLoginRole = checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta);
    if (!isVisitorRole && !isLoginRole && !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta) && !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {
      if (tokenRefreshing) {
        await waitForTokenRefreshed(method, waitingList);
      }
    }
    if (!isVisitorRole && !isLoginRole) {
      await assignToken(method);
    }
    return onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest(method);
  };
  const onResponseRefreshToken = (onRespondedHandlers) => {
    const respondedRecord = onResponded2Record(onRespondedHandlers);
    return {
      ...respondedRecord,
      onSuccess: async (response, method) => {
        if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) && !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) && !checkMethodRole(method, (refreshTokenOnSuccess === null || refreshTokenOnSuccess === void 0 ? void 0 : refreshTokenOnSuccess.metaMatches) || defaultRefreshTokenMeta)) {
          const dataResent = await refreshTokenIfExpired(method, waitingList, (refreshing) => {
            tokenRefreshing = refreshing;
          }, [response, method], refreshTokenOnSuccess, tokenRefreshing);
          if (dataResent) {
            return dataResent;
          }
        }
        await callHandlerIfMatchesMeta(method, login, defaultLoginMeta, response);
        await callHandlerIfMatchesMeta(method, logout, defaultLogoutMeta, response);
        return (respondedRecord.onSuccess || $self)(response, method);
      },
      onError: async (error, method) => {
        if (!checkMethodRole(method, visitorMeta || defaultVisitorMeta) && !checkMethodRole(method, (login === null || login === void 0 ? void 0 : login.metaMatches) || defaultLoginMeta) && !checkMethodRole(method, (refreshTokenOnError === null || refreshTokenOnError === void 0 ? void 0 : refreshTokenOnError.metaMatches) || defaultRefreshTokenMeta)) {
          const dataResent = await refreshTokenIfExpired(method, waitingList, (refreshing) => {
            tokenRefreshing = refreshing;
          }, [error, method], refreshTokenOnError, tokenRefreshing);
          if (dataResent) {
            return dataResent;
          }
        }
        return (respondedRecord.onError || noop)(error, method);
      }
    };
  };
  return {
    waitingList,
    onAuthRequired,
    onResponseRefreshToken
  };
};
var throwFn = (error) => {
  throw error;
};
function useCallback(onCallbackChange = noop) {
  let callbacks = [];
  const setCallback = (fn) => {
    if (!callbacks.includes(fn)) {
      callbacks.push(fn);
      onCallbackChange(callbacks);
    }
    return () => {
      callbacks = filterItem(callbacks, (e) => e !== fn);
      onCallbackChange(callbacks);
    };
  };
  const triggerCallback = (...args) => {
    if (callbacks.length > 0) {
      return forEach(callbacks, (fn) => fn(...args));
    }
  };
  const removeAllCallback = () => {
    callbacks = [];
    onCallbackChange(callbacks);
  };
  return [setCallback, triggerCallback, removeAllCallback];
}
var debounce = (fn, delay) => {
  let timer = nullValue;
  return function debounceFn(...args) {
    const bindFn = fn.bind(this, ...args);
    const delayMill = isNumber(delay) ? delay : delay(...args);
    timer && clearTimeoutTimer(timer);
    if (delayMill > 0) {
      timer = setTimeoutFn(bindFn, delayMill);
    } else {
      bindFn();
    }
  };
};
var getHandlerMethod2 = (methodHandler, args = []) => {
  const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;
  const assert2 = createAssert("scene");
  assert2(instanceOf(methodInstance, Method), "hook handler must be a method instance or a function that returns method instance");
  return methodInstance;
};
var mapObject = (obj, callback) => {
  const ret = {};
  for (const key in obj) {
    ret[key] = callback(obj[key], key, obj);
  }
  return ret;
};
var EnumHookType;
(function(EnumHookType2) {
  EnumHookType2[EnumHookType2["USE_REQUEST"] = 1] = "USE_REQUEST";
  EnumHookType2[EnumHookType2["USE_WATCHER"] = 2] = "USE_WATCHER";
  EnumHookType2[EnumHookType2["USE_FETCHER"] = 3] = "USE_FETCHER";
})(EnumHookType || (EnumHookType = {}));
function statesHookHelper(statesHook, referingObject = {
  trackedKeys: {},
  bindError: falseValue,
  initialRequest: falseValue,
  ...injectReferingObject()
}) {
  const ref = (initialValue) => statesHook.ref ? statesHook.ref(initialValue) : { current: initialValue };
  referingObject = ref(referingObject).current;
  const exportState = (state) => (statesHook.export || $self)(state, referingObject);
  const memorize = (fn) => {
    if (!isFn(statesHook.memorize)) {
      return fn;
    }
    const memorizedFn = statesHook.memorize(fn);
    memorizedFn.memorized = trueValue;
    return memorizedFn;
  };
  const { dehydrate } = statesHook;
  const update = (newValue, state, key) => newValue !== dehydrate(state, key, referingObject) && referingObject.trackedKeys[key] && statesHook.update(newValue, state, key, referingObject);
  const mapDeps = (deps) => mapItem(deps, (item) => instanceOf(item, FrameworkReadableState) ? item.e : item);
  const createdStateList = [];
  const depKeys = {};
  return {
    create: (initialValue, key) => {
      pushItem(createdStateList, key);
      return newInstance(FrameworkState, statesHook.create(initialValue, key, referingObject), key, (state) => dehydrate(state, key, referingObject), exportState, (state, newValue) => update(newValue, state, key));
    },
    computed: (getter, depList, key) => {
      forEach(depList, (dep) => {
        if (dep.k) {
          depKeys[dep.k] = trueValue;
        }
      });
      return newInstance(FrameworkReadableState, statesHook.computed(getter, mapDeps(depList), key, referingObject), key, (state) => dehydrate(state, key, referingObject), exportState);
    },
    effectRequest: (effectRequestParams) => statesHook.effectRequest(effectRequestParams, referingObject),
    ref,
    watch: (source, callback) => statesHook.watch(mapDeps(source), callback, referingObject),
    onMounted: (callback) => statesHook.onMounted(callback, referingObject),
    onUnmounted: (callback) => statesHook.onUnmounted(callback, referingObject),
    memorize,
    /**
     * refering object that sharing some value with this object.
     */
    __referingObj: referingObject,
    /**
     * expose provider for specified use hook.
     * @param object object that contains state proxy, framework state, operating function and event binder.
     * @returns provider component.
     */
    exposeProvider: (object) => {
      const provider = {};
      const originalStatesMap = {};
      const stateKeys = [];
      for (const key in object) {
        const value = object[key];
        const isValueFunction = isFn(value);
        if (isValueFunction && !referingObject.trackedKeys[key]) {
          provider[key] = key.startsWith("on") ? (...args) => {
            value(...args);
            return completedProvider;
          } : value.memorized ? value : memorize(value);
        } else {
          if (!includes(["uploading", "downloading"], key) && !key.startsWith("__")) {
            pushItem(stateKeys, key);
          }
          const isFrameworkState = instanceOf(value, FrameworkReadableState);
          if (isFrameworkState) {
            originalStatesMap[key] = value.s;
          }
          ObjectCls.defineProperty(provider, key, {
            get: () => {
              referingObject.trackedKeys[key] = trueValue;
              return isFrameworkState ? value.e : value;
            },
            // set need to set an function,
            // otherwise it will throw `TypeError: Cannot set property __referingObj of #<Object> which has only a getter` when setting value
            set: noop,
            enumerable: trueValue,
            configurable: trueValue
          });
        }
      }
      const { update: nestedHookUpdate, __proxyState: nestedProxyState } = provider;
      referingObject.trackedKeys = {
        ...depKeys
      };
      referingObject.bindError = falseValue;
      const { then: providerThen } = provider;
      const extraProvider = {
        // expose referingObject automatically.
        __referingObj: referingObject,
        // the new updating function that can update the new states and nested hook states.
        update: memorize((newStates) => {
          objectKeys(newStates).forEach((key) => {
            if (includes(createdStateList, key)) {
              update(newStates[key], originalStatesMap[key], key);
            } else if (key in provider && isFn(nestedHookUpdate)) {
              nestedHookUpdate({
                [key]: newStates[key]
              });
            }
          });
        }),
        __proxyState: memorize((key) => {
          if (includes(createdStateList, key) && instanceOf(object[key], FrameworkReadableState)) {
            referingObject.trackedKeys[key] = trueValue;
            return object[key];
          }
          return nestedProxyState(key);
        }),
        /**
         * send and wait for responding with `await`
         * this is always used in `nuxt3` and suspense in vue3
         * @example
         * ```js
         * const { loading, data, error } = await useRequest(...);
         * ```
         */
        then(onfulfilled, onrejected) {
          forEach(stateKeys, (key) => {
            referingObject.trackedKeys[key] = trueValue;
          });
          const handleFullfilled = () => {
            deleteAttr(completedProvider, "then");
            onfulfilled(completedProvider);
          };
          isFn(providerThen) ? providerThen(handleFullfilled, onrejected) : handleFullfilled();
        }
      };
      const completedProvider = objAssign(provider, extraProvider);
      return completedProvider;
    },
    /**
     * transform state proxies to object.
     * @param states proxy array of framework states
     * @param filterKey filter key of state proxy
     * @returns an object that contains the states of target form
     */
    objectify: (states, filterKey) => states.reduce((result, item) => {
      result[item.k] = filterKey ? item[filterKey] : item;
      return result;
    }, {}),
    transformState2Proxy: (state, key) => newInstance(FrameworkState, state, key, (state2) => dehydrate(state2, key, referingObject), exportState, (state2, newValue) => update(newValue, state2, key))
  };
}
var coreAssert = createAssert("");
var requestHookAssert = createAssert("useRequest");
var watcherHookAssert = createAssert("useWatcher");
var fetcherHookAssert = createAssert("useFetcher");
var coreHookAssert = (hookType) => ({
  [EnumHookType.USE_REQUEST]: requestHookAssert,
  [EnumHookType.USE_WATCHER]: watcherHookAssert,
  [EnumHookType.USE_FETCHER]: fetcherHookAssert
})[hookType];
var assertMethod = (assert2, methodInstance) => assert2(instanceOf(methodInstance, Method), "expected a method instance.");
var KEY_SUCCESS = "success";
var KEY_ERROR = "error";
var KEY_COMPLETE = "complete";
var createHook = (ht, c, eventManager, ro) => ({
  /** The method instance of the last request */
  m: undefinedValue,
  /** sent method keys */
  rf: {},
  /** frontStates */
  fs: {},
  /** eventManager */
  em: eventManager,
  /** hookType, useRequest=1, useWatcher=2, useFetcher=3 */
  ht,
  /** hook config */
  c,
  /** referingObject */
  ro,
  /** merged states */
  ms: {}
});
var AlovaEventBase = class _AlovaEventBase {
  constructor(method, args) {
    this.method = method;
    this.args = args;
  }
  clone() {
    return { ...this };
  }
  static spawn(method, args) {
    return newInstance(_AlovaEventBase, method, args);
  }
};
var AlovaSuccessEvent = class extends AlovaEventBase {
  constructor(base, data, fromCache) {
    super(base.method, base.args);
    this.data = data;
    this.fromCache = fromCache;
  }
};
var AlovaErrorEvent = class extends AlovaEventBase {
  constructor(base, error) {
    super(base.method, base.args);
    this.error = error;
  }
};
var AlovaCompleteEvent = class extends AlovaEventBase {
  constructor(base, status, data, fromCache, error) {
    super(base.method, base.args);
    this.status = status;
    this.data = data;
    this.fromCache = status === "error" ? false : fromCache;
    this.error = error;
  }
};
var SQEvent = class {
  constructor(behavior, method, silentMethod) {
    this.behavior = behavior;
    this.method = method;
    this.silentMethod = silentMethod;
  }
};
var GlobalSQEvent = class extends SQEvent {
  constructor(behavior, method, silentMethod, queueName, retryTimes) {
    super(behavior, method, silentMethod);
    this.queueName = queueName;
    this.retryTimes = retryTimes;
  }
};
var GlobalSQSuccessEvent = class extends GlobalSQEvent {
  constructor(behavior, method, silentMethod, queueName, retryTimes, data, vDataResponse) {
    super(behavior, method, silentMethod, queueName, retryTimes);
    this.data = data;
    this.vDataResponse = vDataResponse;
  }
};
var GlobalSQErrorEvent = class extends GlobalSQEvent {
  constructor(behavior, method, silentMethod, queueName, retryTimes, error, retryDelay) {
    super(behavior, method, silentMethod, queueName, retryTimes);
    this.error = error;
    this.retryDelay = retryDelay;
  }
};
var GlobalSQFailEvent = class extends GlobalSQEvent {
  constructor(behavior, method, silentMethod, queueName, retryTimes, error) {
    super(behavior, method, silentMethod, queueName, retryTimes);
    this.error = error;
  }
};
var ScopedSQEvent = class extends SQEvent {
  constructor(behavior, method, silentMethod, args) {
    super(behavior, method, silentMethod);
    this.args = args;
  }
};
var ScopedSQSuccessEvent = class extends ScopedSQEvent {
  constructor(behavior, method, silentMethod, args, data) {
    super(behavior, method, silentMethod, args);
    this.data = data;
  }
};
var ScopedSQErrorEvent = class extends ScopedSQEvent {
  constructor(behavior, method, silentMethod, args, error) {
    super(behavior, method, silentMethod, args);
    this.error = error;
  }
};
var ScopedSQRetryEvent = class extends ScopedSQEvent {
  constructor(behavior, method, silentMethod, args, retryTimes, retryDelay) {
    super(behavior, method, silentMethod, args);
    this.retryTimes = retryTimes;
    this.retryDelay = retryDelay;
  }
};
var ScopedSQCompleteEvent = class extends ScopedSQEvent {
  constructor(behavior, method, silentMethod, args, status, data, error) {
    super(behavior, method, silentMethod, args);
    this.status = status;
    this.data = data;
    this.error = error;
  }
};
var RetriableRetryEvent = class extends AlovaEventBase {
  constructor(base, retryTimes, retryDelay) {
    super(base.method, base.args);
    this.retryTimes = retryTimes;
    this.retryDelay = retryDelay;
  }
};
var RetriableFailEvent = class extends AlovaErrorEvent {
  constructor(base, error, retryTimes) {
    super(base, error);
    this.retryTimes = retryTimes;
  }
};
var defaultMiddleware = (_, next) => next();
var stateCache = {};
var getStateCache = (namespace, key) => {
  const cachedState = stateCache[namespace] || {};
  return cachedState[key] ? Array.from(cachedState[key]) : [];
};
var setStateCache = (namespace, key, hookInstance) => {
  const cachedState = stateCache[namespace] = stateCache[namespace] || {};
  if (!cachedState[key]) {
    cachedState[key] = newInstance(Set);
  }
  cachedState[key].add(hookInstance);
};
var removeStateCache = (namespace, key, hookInstance) => {
  const cachedState = stateCache[namespace];
  const hookSet = cachedState[key];
  if (cachedState && hookSet) {
    hookInstance ? hookSet.delete(hookInstance) : hookSet.clear();
    if (hookSet.size === 0) {
      deleteAttr(cachedState, key);
    }
  }
};
function useHookToSendRequest(hookInstance, methodHandler, sendCallingArgs = []) {
  const currentHookAssert = coreHookAssert(hookInstance.ht);
  let methodInstance = getHandlerMethod(methodHandler, currentHookAssert, sendCallingArgs);
  const { fs: frontStates, ht: hookType, c: useHookConfig } = hookInstance;
  const { loading: loadingState, data: dataState, error: errorState } = frontStates;
  const isFetcher = hookType === EnumHookType.USE_FETCHER;
  const { force: forceRequest = falseValue, middleware = defaultMiddleware } = useHookConfig;
  const alovaInstance = getContext(methodInstance);
  const { id } = alovaInstance;
  const methodKey = getMethodInternalKey(methodInstance);
  const { abortLast = trueValue } = useHookConfig;
  const isFirstRequest = !hookInstance.m;
  hookInstance.m = methodInstance;
  return (async () => {
    let removeStates = noop;
    let isNextCalled = falseValue;
    let responseHandlePromise = promiseResolve(undefinedValue);
    let offDownloadEvent = noop;
    let offUploadEvent = noop;
    const cachedResponse = await queryCache(methodInstance);
    let fromCache = () => !!cachedResponse;
    let controlledLoading = falseValue;
    if (!isFetcher) {
      setStateCache(id, methodKey, hookInstance);
      removeStates = () => removeStateCache(id, methodKey, hookInstance);
    }
    const guardNext = (guardNextConfig) => {
      isNextCalled = trueValue;
      const { force: guardNextForceRequest = forceRequest, method: guardNextReplacingMethod = methodInstance } = guardNextConfig || {};
      const forceRequestFinally = sloughConfig(guardNextForceRequest, [
        newInstance(AlovaEventBase, methodInstance, sendCallingArgs)
      ]);
      const progressUpdater = (stage) => ({ loaded, total }) => {
        frontStates[stage].v = {
          loaded,
          total
        };
      };
      methodInstance = guardNextReplacingMethod;
      hookInstance.rf[methodKey] = removeStates;
      if (!controlledLoading) {
        loadingState.v = !!forceRequestFinally || !cachedResponse;
      }
      const { downloading: enableDownload, uploading: enableUpload } = hookInstance.ro.trackedKeys;
      offDownloadEvent = enableDownload ? methodInstance.onDownload(progressUpdater("downloading")) : offDownloadEvent;
      offUploadEvent = enableUpload ? methodInstance.onUpload(progressUpdater("uploading")) : offUploadEvent;
      responseHandlePromise = methodInstance.send(forceRequestFinally);
      fromCache = () => methodInstance.fromCache || falseValue;
      return responseHandlePromise;
    };
    const commonContext = {
      method: methodInstance,
      cachedResponse,
      config: useHookConfig,
      abort: () => methodInstance.abort()
    };
    const toUpdateResponse = () => hookType !== EnumHookType.USE_WATCHER || !abortLast || hookInstance.m === methodInstance;
    const controlLoading = (control = trueValue) => {
      if (control && isFirstRequest) {
        loadingState.v = falseValue;
      }
      controlledLoading = control;
    };
    const middlewareCompletePromise = isFetcher ? middleware({
      ...commonContext,
      args: sendCallingArgs,
      fetch: (methodInstance2, ...args) => {
        assertMethod(currentHookAssert, methodInstance2);
        return useHookToSendRequest(hookInstance, methodInstance2, args);
      },
      proxyStates: omit(frontStates, "data"),
      controlLoading
    }, guardNext) : middleware({
      ...commonContext,
      args: sendCallingArgs,
      send: (...args) => useHookToSendRequest(hookInstance, methodHandler, args),
      proxyStates: frontStates,
      controlLoading
    }, guardNext);
    let finallyResponse = undefinedValue;
    const baseEvent = AlovaEventBase.spawn(methodInstance, sendCallingArgs);
    try {
      const middlewareReturnedData = await middlewareCompletePromise;
      const afterSuccess = (data) => {
        if (!isFetcher) {
          toUpdateResponse() && (dataState.v = data);
        } else if (hookInstance.c.updateState !== falseValue) {
          forEach(getStateCache(id, methodKey), (hookInstance2) => {
            hookInstance2.fs.data.v = data;
          });
        }
        if (toUpdateResponse()) {
          errorState.v = undefinedValue;
          !controlledLoading && (loadingState.v = falseValue);
          hookInstance.em.emit(KEY_SUCCESS, newInstance(AlovaSuccessEvent, baseEvent, data, fromCache()));
          hookInstance.em.emit(KEY_COMPLETE, newInstance(AlovaCompleteEvent, baseEvent, KEY_SUCCESS, data, fromCache(), undefinedValue));
        }
        return data;
      };
      finallyResponse = // When no data is returned or undefined is returned in the middleware, get the real response data
      // Otherwise, use the returned data and no longer wait for the response promise. At this time, you also need to call the response callback.
      middlewareReturnedData !== undefinedValue ? afterSuccess(middlewareReturnedData) : isNextCalled ? (
        // There are two possibilities when middlewareCompletePromise is resolve
        // 1. The request is normal
        // 2. The request is incorrect, but the error is captured by the middleware function. At this time, the success callback will also be called, that is, afterSuccess(undefinedValue)
        await promiseThen(responseHandlePromise, afterSuccess, () => afterSuccess(undefinedValue))
      ) : (
        // If is next called is not called, no data is returned
        undefinedValue
      );
      !isNextCalled && !controlledLoading && (loadingState.v = falseValue);
    } catch (error) {
      if (toUpdateResponse()) {
        errorState.v = error;
        !controlledLoading && (loadingState.v = falseValue);
        hookInstance.em.emit(KEY_ERROR, newInstance(AlovaErrorEvent, baseEvent, error));
        hookInstance.em.emit(KEY_COMPLETE, newInstance(AlovaCompleteEvent, baseEvent, KEY_ERROR, undefinedValue, fromCache(), error));
      }
      throw error;
    }
    offDownloadEvent();
    offUploadEvent();
    return finallyResponse;
  })();
}
var refCurrent = (ref) => ref.current;
function createRequestState(hookType, methodHandler, useHookConfig, initialData, immediate = falseValue, watchingStates, debounceDelay = 0) {
  var _a;
  useHookConfig = { ...useHookConfig };
  let initialLoading = !!immediate;
  let cachedResponse = undefinedValue;
  if (immediate) {
    try {
      const methodInstance = getHandlerMethod(methodHandler, coreHookAssert(hookType));
      const alovaInstance = getContext(methodInstance);
      const l1CacheResult = alovaInstance.l1Cache.get(buildNamespacedCacheKey(alovaInstance.id, getMethodInternalKey(methodInstance)));
      if (l1CacheResult && !instanceOf(l1CacheResult, PromiseCls)) {
        const [data2, expireTimestamp] = l1CacheResult;
        if (!expireTimestamp || expireTimestamp > getTime()) {
          cachedResponse = data2;
        }
      }
      const forceRequestFinally = sloughConfig((_a = useHookConfig.force) !== null && _a !== void 0 ? _a : falseValue);
      initialLoading = !!forceRequestFinally || !cachedResponse;
    } catch (_b) {
    }
  }
  const { create, effectRequest, ref, objectify, exposeProvider, transformState2Proxy, __referingObj: referingObject } = statesHookHelper(promiseStatesHook(), useHookConfig.__referingObj);
  const progress = {
    total: 0,
    loaded: 0
  };
  const { managedStates = {} } = useHookConfig;
  const managedStatesProxy = mapObject(managedStates, (state, key) => transformState2Proxy(state, key));
  const data = create(cachedResponse !== null && cachedResponse !== void 0 ? cachedResponse : isFn(initialData) ? initialData() : initialData, "data");
  const loading = create(initialLoading, "loading");
  const error = create(undefinedValue, "error");
  const downloading = create({ ...progress }, "downloading");
  const uploading = create({ ...progress }, "uploading");
  const frontStates = objectify([data, loading, error, downloading, uploading]);
  const eventManager = createEventManager();
  const hookInstance = refCurrent(ref(createHook(hookType, useHookConfig, eventManager, referingObject)));
  hookInstance.fs = frontStates;
  hookInstance.em = eventManager;
  hookInstance.c = useHookConfig;
  hookInstance.ms = { ...frontStates, ...managedStatesProxy };
  const hasWatchingStates = watchingStates !== undefinedValue;
  const handleRequest = (handler = methodHandler, sendCallingArgs) => useHookToSendRequest(hookInstance, handler, sendCallingArgs);
  const hookRequestPromiseCallback = ref(undefinedValue);
  const isInitialRequest = ref(falseValue);
  const onceRunner = refCurrent(ref(createSyncOnceRunner()));
  const wrapEffectRequest = (ro = referingObject, handler) => {
    onceRunner(() => {
      if (!globalConfigMap.ssr || refCurrent(hookRequestPromiseCallback)) {
        referingObject.initialRequest = isInitialRequest.current = trueValue;
        promiseThen(handleRequest(handler), () => {
          var _a2;
          (_a2 = refCurrent(hookRequestPromiseCallback)) === null || _a2 === void 0 ? void 0 : _a2.resolve();
        }, (error2) => {
          var _a2;
          if (!ro.bindError && !ro.trackedKeys.error && !refCurrent(hookRequestPromiseCallback)) {
            throw error2;
          }
          (_a2 = refCurrent(hookRequestPromiseCallback)) === null || _a2 === void 0 ? void 0 : _a2.reject(error2);
        });
      }
    });
  };
  const debouncingSendHandler = ref(debounce((_, ro, handler) => wrapEffectRequest(ro, handler), (changedIndex) => isNumber(changedIndex) ? isArray(debounceDelay) ? debounceDelay[changedIndex] : debounceDelay : 0));
  effectRequest({
    handler: (
      // When `watchingStates` is an array, it indicates the watching states (including an empty array). When it is undefined, it indicates the non-watching state.
      hasWatchingStates ? (changedIndex) => debouncingSendHandler.current(changedIndex, referingObject, methodHandler) : () => wrapEffectRequest(referingObject)
    ),
    removeStates: () => {
      forEach(objectValues(hookInstance.rf), (fn) => fn());
    },
    frontStates: { ...frontStates, ...managedStatesProxy },
    watchingStates,
    immediate: immediate !== null && immediate !== void 0 ? immediate : trueValue
  });
  const hookProvider = exposeProvider({
    ...objectify([data, loading, error, downloading, uploading]),
    abort: () => hookInstance.m && hookInstance.m.abort(),
    /**
     * Manually initiate a request by executing this method
     * @param sendCallingArgs Parameters passed in when calling the send function
     * @param methodInstance method object
     * @param isFetcher Whether to call isFetcher
     * @returns Request promise
     */
    send: (sendCallingArgs, methodInstance) => handleRequest(methodInstance, sendCallingArgs),
    onSuccess(handler) {
      eventManager.on(KEY_SUCCESS, handler);
    },
    onError(handler) {
      referingObject.bindError = trueValue;
      eventManager.on(KEY_ERROR, handler);
    },
    onComplete(handler) {
      eventManager.on(KEY_COMPLETE, handler);
    },
    /**
     * send and wait for responding with `await`
     * this is always used in `nuxt3` and `<suspense>` in vue3
     * @example
     * ```js
     * const { loading, data, error } = await useRequest(...);
     * ```
     */
    then(onfulfilled, onrejected) {
      const { promise, resolve, reject } = usePromise();
      hookRequestPromiseCallback.current = {
        resolve,
        reject
      };
      setTimeoutFn(() => {
        !isInitialRequest.current && resolve();
      }, 10);
      promiseThen(promise, () => {
        onfulfilled(hookProvider);
      }, onrejected);
    }
  });
  return hookProvider;
}
function useFetcher(config = {}) {
  const props = createRequestState(EnumHookType.USE_FETCHER, noop, config);
  const { send } = props;
  deleteAttr(props, "send");
  return objAssign(props, {
    /**
     * Fetch data fetch will definitely send a request, and if the currently requested data has a corresponding management state, this state will be updated.
     * @param matcher Method object
     */
    fetch: (matcher, ...args) => {
      assertMethod(fetcherHookAssert, matcher);
      return send(args, matcher);
    }
  });
}
function useRequest(handler, config = {}) {
  const { immediate = trueValue, initialData } = config;
  const props = createRequestState(EnumHookType.USE_REQUEST, handler, config, initialData, !!immediate);
  const { send } = props;
  return objAssign(props, {
    send: (...args) => send(args)
  });
}
function useWatcher(handler, watchingStates, config = {}) {
  watcherHookAssert(watchingStates && len(watchingStates) > 0, "expected at least one watching state");
  const { immediate, debounce: debounce2 = 0, initialData } = config;
  const props = createRequestState(
    EnumHookType.USE_WATCHER,
    handler,
    config,
    initialData,
    !!immediate,
    // !!immediate means not send request immediately
    watchingStates,
    debounce2
  );
  const { send } = props;
  return objAssign(props, {
    send: (...args) => send(args)
  });
}
var createSnapshotMethodsManager = (handler) => {
  let methodSnapshots = {};
  return {
    snapshots: () => methodSnapshots,
    save(methodInstance, force = falseValue) {
      const key = getMethodInternalKey(methodInstance);
      if (!methodSnapshots[key] || force) {
        methodSnapshots[key] = {
          entity: methodInstance
        };
      }
    },
    get: (entityOrPage) => methodSnapshots[getMethodInternalKey(instanceOf(entityOrPage, Method) ? entityOrPage : handler(entityOrPage))],
    remove(key) {
      if (key) {
        delete methodSnapshots[key];
      } else {
        methodSnapshots = {};
      }
    }
  };
};
var paginationAssert = createAssert("usePagination");
var indexAssert = (index, rawData) => paginationAssert(isNumber(index) && index < len(rawData), "index must be a number that less than list length");
var parseSendArgs = (args) => [
  args[args.length - 2],
  // refreshPage
  args[args.length - 1],
  // isRefresh
  args.slice(0, args.length - 2)
  // send args
];
var usePagination = (handler, config = {}) => {
  const { create, computed, ref, watch, exposeProvider, objectify, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());
  const { preloadPreviousPage = trueValue, preloadNextPage = trueValue, total: totalGetter = (res) => res.total, data: dataGetter = (res) => res.data, append = falseValue, initialPage = 1, initialPageSize = 10, watchingStates = [], initialData, immediate = trueValue, middleware, force = noop, actions = {}, ...others } = config;
  const handlerRef = ref(handler);
  const isReset = ref(falseValue);
  const page = create(initialPage, "page");
  const pageSize = create(initialPageSize, "pageSize");
  const data = create(initialData ? dataGetter(initialData) || [] : [], "data");
  const total = create(initialData ? totalGetter(initialData) : undefinedValue, "total");
  const { snapshots: methodSnapshots, get: getSnapshotMethods, save: saveSnapshot, remove: removeSnapshot } = ref(createSnapshotMethodsManager((page2) => handlerRef.current(page2, pageSize.v))).current;
  const listDataGetter = (rawData) => dataGetter(rawData) || rawData;
  const fetchStates = useFetcher({
    __referingObj: referingObject,
    updateState: falseValue,
    force: ({ args }) => args[len(args) - 1]
  });
  const { loading, fetch: fetch2, abort: abortFetch, onSuccess: onFetchSuccess } = fetchStates;
  const fetchingRef = ref(loading);
  const getHandlerMethod3 = (refreshPage = page.v, customArgs = []) => {
    const handlerMethod = handler(refreshPage, pageSize.v, ...customArgs);
    saveSnapshot(handlerMethod);
    return handlerMethod;
  };
  watch(watchingStates, () => {
    page.v = initialPage;
    isReset.current = trueValue;
  });
  const delegationActions = ref({});
  const status = create("", "status");
  const removing = create([], "removing");
  const replacing = create(undefinedValue, "replacing");
  const pageCount = computed(() => {
    const totalVal = total.v;
    return totalVal !== undefinedValue ? Math.ceil(totalVal / pageSize.v) : undefinedValue;
  }, [pageSize, total], "pageCount");
  const createDelegationAction = (actionName) => (...args) => delegationActions.current[actionName](...args);
  const states = useWatcher((...args) => {
    const [refreshPage, , customArgs] = parseSendArgs(args);
    return getHandlerMethod3(refreshPage, customArgs);
  }, [...watchingStates, page.e, pageSize.e], {
    __referingObj: referingObject,
    immediate,
    initialData,
    managedStates: objectify([data, page, pageSize, total], "s"),
    middleware(ctx, next) {
      if (!middleware) {
        return next();
      }
      return middleware({
        ...ctx,
        delegatingActions: {
          refresh: createDelegationAction("refresh"),
          insert: createDelegationAction("insert"),
          remove: createDelegationAction("remove"),
          replace: createDelegationAction("replace"),
          reload: createDelegationAction("reload"),
          getState: (stateKey) => {
            const states2 = {
              page,
              pageSize,
              data,
              pageCount,
              total,
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              isLastPage
            };
            return states2[stateKey].v;
          }
        }
      }, next);
    },
    force: (event) => event.args[1] || (isFn(force) ? force(event) : force),
    ...others
  });
  const { send } = states;
  const nestedData = states.__proxyState("data");
  const canPreload = async (payload) => {
    const { rawData = nestedData.v, preloadPage, fetchMethod, forceRequest = falseValue, isNextPage = falseValue } = payload;
    const pageCountVal = pageCount.v;
    const exceedPageCount = pageCountVal ? preloadPage > pageCountVal : isNextPage ? len(listDataGetter(rawData)) < pageSize.v : falseValue;
    const isMatchPageScope = preloadPage > 0 && !exceedPageCount;
    if (!isMatchPageScope) {
      return falseValue;
    }
    const { e: expireMilliseconds } = getLocalCacheConfigParam(fetchMethod);
    const hasCache = await queryCache(fetchMethod);
    return expireMilliseconds(MEMORY) <= getTime() ? falseValue : forceRequest || !hasCache;
  };
  const fetchNextPage = async (rawData, force2, customArgs = []) => {
    const nextPage = page.v + 1;
    const fetchMethod = getHandlerMethod3(nextPage, customArgs);
    if (preloadNextPage && await canPreload({
      rawData,
      preloadPage: nextPage,
      fetchMethod,
      isNextPage: trueValue,
      forceRequest: force2
    })) {
      promiseCatch(fetch2(fetchMethod, ...customArgs, force2), noop);
    }
  };
  const fetchPreviousPage = async (rawData, customArgs = []) => {
    const prevPage = page.v - 1;
    const fetchMethod = getHandlerMethod3(prevPage, customArgs);
    if (preloadPreviousPage && await canPreload({
      rawData,
      preloadPage: prevPage,
      fetchMethod
    })) {
      promiseCatch(fetch2(fetchMethod, ...customArgs, undefinedValue), noop);
    }
  };
  const computeIsLastPage = () => {
    const dataRaw = nestedData.v;
    if (!dataRaw) {
      return trueValue;
    }
    const statesDataVal = listDataGetter(dataRaw);
    const pageVal = page.v;
    const pageCountVal = pageCount.v;
    const dataLen = isArray(statesDataVal) ? len(statesDataVal) : 0;
    return pageCountVal ? pageVal >= pageCountVal : dataLen < pageSize.v;
  };
  const isLastPage = create(computeIsLastPage(), "isLastPage");
  watch([page, pageCount, nestedData, pageSize], async () => {
    setTimeoutFn(() => {
      isLastPage.v = computeIsLastPage();
    });
  });
  const updateCurrentPageCache = async () => {
    const snapshotItem = getSnapshotMethods(page.v);
    if (snapshotItem) {
      await setCache(snapshotItem.entity, (rawData) => {
        if (rawData) {
          const cachedListData = listDataGetter(rawData) || [];
          splice(cachedListData, 0, len(cachedListData), ...data.v);
          return rawData;
        }
      });
    }
  };
  onFetchSuccess(({ method, data: rawData }) => {
    const snapshotItem = getSnapshotMethods(page.v);
    if (snapshotItem && getMethodInternalKey(snapshotItem.entity) === getMethodInternalKey(method)) {
      const listData = listDataGetter(rawData);
      if (append) {
        const dataRaw = data.v;
        const pageSizeVal = pageSize.v;
        const replaceNumber = len(dataRaw) % pageSizeVal;
        if (replaceNumber > 0) {
          const rawData2 = [...data.v];
          splice(rawData2, (page.v - 1) * pageSizeVal, replaceNumber, ...listData);
          data.v = rawData2;
        }
      } else {
        data.v = listData;
      }
    }
  });
  const awaitResolve = ref(undefinedValue);
  const awaitReject = ref(undefinedValue);
  states.onSuccess(({ data: rawData, args, method }) => {
    const [refreshPage, isRefresh, customArgs] = parseSendArgs(args);
    const { total: cachedTotal } = getSnapshotMethods(method) || {};
    const typedRawData = rawData;
    total.v = cachedTotal !== undefinedValue ? cachedTotal : totalGetter(typedRawData);
    if (!isRefresh) {
      fetchPreviousPage(typedRawData, customArgs);
      fetchNextPage(typedRawData, falseValue, customArgs);
    }
    const pageSizeVal = pageSize.v;
    const listData = listDataGetter(typedRawData);
    paginationAssert(isArray(listData), "Got wrong array, did you return the correct array of list in `data` function");
    if (append) {
      if (isReset.current) {
        data.v = [];
      }
      if (refreshPage === undefinedValue) {
        data.v = [...data.v, ...listData];
      } else if (refreshPage) {
        const rawData2 = [...data.v];
        splice(rawData2, (refreshPage - 1) * pageSizeVal, pageSizeVal, ...listData);
        data.v = rawData2;
      }
    } else {
      data.v = listData;
    }
  }).onSuccess(({ data: data2 }) => {
    var _a;
    (_a = awaitResolve.current) === null || _a === void 0 ? void 0 : _a.call(awaitResolve, data2);
  }).onError(({ error }) => {
    var _a;
    (_a = awaitReject.current) === null || _a === void 0 ? void 0 : _a.call(awaitReject, error);
  }).onComplete(() => {
    isReset.current = falseValue;
  });
  const getItemIndex = (item) => {
    const index = data.v.indexOf(item);
    paginationAssert(index >= 0, "item is not found in list");
    return index;
  };
  const { addQueue: add2AsyncQueue, onComplete: onAsyncQueueRunComplete } = ref(createAsyncQueue()).current;
  const refresh = async (pageOrItemPage = page.v) => {
    let refreshPage = pageOrItemPage;
    let awaitPromise = promiseResolve();
    if (append) {
      if (!isNumber(pageOrItemPage)) {
        const itemIndex = getItemIndex(pageOrItemPage);
        refreshPage = Math.floor(itemIndex / pageSize.v) + 1;
      }
      paginationAssert(refreshPage <= page.v, "refresh page can't greater than page");
      awaitPromise = send(refreshPage, trueValue);
    } else {
      paginationAssert(isNumber(refreshPage), "unable to calculate refresh page by item in pagination mode");
      awaitPromise = refreshPage === page.v ? send(undefinedValue, trueValue) : fetch2(handler(refreshPage, pageSize.v), trueValue);
    }
    return awaitPromise;
  };
  const invalidatePaginationCache = async (all = falseValue) => {
    const pageVal = page.v;
    const snapshotObj = methodSnapshots();
    let snapshots = objectValues(snapshotObj);
    if (all) {
      removeSnapshot();
    } else {
      const excludeSnapshotKeys = mapItem(filterItem([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], Boolean), ({ entity }) => getMethodInternalKey(entity));
      snapshots = mapItem(filterItem(objectKeys(snapshotObj), (key) => !includes(excludeSnapshotKeys, key)), (key) => {
        const item = snapshotObj[key];
        delete snapshotObj[key];
        return item;
      });
    }
    await invalidateCache(mapItem(snapshots, ({ entity }) => entity));
  };
  const resetCache = async () => {
    fetchingRef.current && abortFetch();
    await invalidatePaginationCache();
    const snapshotItem = getSnapshotMethods(page.v + 1);
    if (snapshotItem) {
      const cachedListData = listDataGetter(await queryCache(snapshotItem.entity) || {}) || [];
      fetchNextPage(undefinedValue, len(cachedListData) < pageSize.v);
    }
  };
  const updateTotal = (offset) => {
    if (offset === 0) {
      return;
    }
    const totalVal = total.v;
    if (isNumber(totalVal)) {
      const offsetedTotal = Math.max(totalVal + offset, 0);
      total.v = offsetedTotal;
      const pageVal = page.v;
      forEach([getSnapshotMethods(pageVal - 1), getSnapshotMethods(pageVal), getSnapshotMethods(pageVal + 1)], (item) => {
        item && (item.total = offsetedTotal);
      });
    }
  };
  const insert = (item, position = 0) => {
    onAsyncQueueRunComplete(resetCache);
    return add2AsyncQueue(async () => {
      const index = isNumber(position) ? position : getItemIndex(position) + 1;
      paginationAssert(index >= 0, "illegal insert position");
      if (isFn(actions.insert)) {
        status.v = "inserting";
        await promiseFinally(actions.insert(item, position), () => {
          status.v = "";
        });
      }
      let popItem = undefinedValue;
      const rawData = [...data.v];
      if (len(rawData) % pageSize.v === 0) {
        popItem = rawData.pop();
      }
      splice(rawData, index, 0, item);
      data.v = rawData;
      updateTotal(1);
      await updateCurrentPageCache();
      if (popItem) {
        const snapshotItem = getSnapshotMethods(page.v + 1);
        if (snapshotItem) {
          await setCache(snapshotItem.entity, (rawData2) => {
            if (rawData2) {
              const cachedListData = listDataGetter(rawData2) || [];
              cachedListData.unshift(popItem);
              cachedListData.pop();
              return rawData2;
            }
          });
        }
      }
    });
  };
  const remove = (...positions) => {
    onAsyncQueueRunComplete(resetCache);
    return add2AsyncQueue(async () => {
      const indexes = mapItem(positions, (position) => {
        const index = isNumber(position) ? position : getItemIndex(position);
        indexAssert(index, data.v);
        return index;
      });
      if (isFn(actions.remove)) {
        status.v = "removing";
        removing.v = [...indexes];
        const p = promiseAll(mapItem(positions, (position) => actions.remove(position)));
        await promiseFinally(p, () => {
          status.v = "";
          removing.v = [];
        });
      }
      const pageVal = page.v;
      const nextPage = pageVal + 1;
      const snapshotItem = getSnapshotMethods(nextPage);
      const fillingItems = [];
      if (snapshotItem) {
        await setCache(snapshotItem.entity, (rawData) => {
          if (rawData) {
            const cachedListData = listDataGetter(rawData);
            if (isArray(cachedListData)) {
              pushItem(fillingItems, ...splice(cachedListData, 0, len(indexes)));
            }
            return rawData;
          }
        });
      }
      const isLastPageVal = computeIsLastPage();
      const fillingItemsLen = len(fillingItems);
      let isLastEmptyPageInNonAppendMode = false;
      if (fillingItemsLen > 0 || isLastPageVal) {
        const newListData = filterItem(data.v, (_, index) => !includes(indexes, index));
        isLastEmptyPageInNonAppendMode = !append && isLastPageVal && len(newListData) <= 0;
        if (!isLastEmptyPageInNonAppendMode && fillingItemsLen > 0) {
          pushItem(newListData, ...fillingItems);
        }
        data.v = newListData;
      } else if (fillingItemsLen <= 0 && !isLastPageVal) {
        refresh(pageVal);
      }
      updateTotal(-len(indexes));
      return updateCurrentPageCache().then(() => {
        if (isLastEmptyPageInNonAppendMode) {
          page.v = pageVal - 1;
        }
      });
    });
  };
  const replace = (item, position) => add2AsyncQueue(async () => {
    paginationAssert(position !== undefinedValue, "expect specify the replace position");
    const index = isNumber(position) ? position : getItemIndex(position);
    indexAssert(index, data.v);
    if (isFn(actions.replace)) {
      status.v = "replacing";
      replacing.v = index;
      await promiseFinally(actions.replace(item, position), () => {
        status.v = "";
        replacing.v = undefinedValue;
      });
    }
    const rawData = [...data.v];
    splice(rawData, index, 1, item);
    data.v = rawData;
    await updateCurrentPageCache();
  });
  const reload = async () => {
    await invalidatePaginationCache(trueValue);
    isReset.current = trueValue;
    page.v === initialPage ? promiseCatch(send(), noop) : page.v = initialPage;
    const { resolve, reject, promise } = usePromise();
    awaitResolve.current = resolve;
    awaitReject.current = reject;
    return promise;
  };
  delegationActions.current = {
    refresh,
    insert,
    remove,
    replace,
    reload
  };
  return exposeProvider({
    ...states,
    ...objectify([data, page, pageCount, pageSize, total, isLastPage, status, removing, replacing]),
    send: (...args) => send(...args, undefinedValue, undefinedValue),
    fetching: fetchStates.loading,
    onFetchSuccess: fetchStates.onSuccess,
    onFetchError: fetchStates.onError,
    onFetchComplete: fetchStates.onComplete,
    refresh,
    insert,
    remove,
    replace,
    reload
  });
};
var assertSerialHandlers = (hookName, serialHandlers) => createAssert(hookName)(isArray(serialHandlers) && len(serialHandlers) > 0, "please use an array to represent serial requests");
var serialMiddleware = (serialHandlers, hookMiddleware, serialRequestMethods = []) => {
  serialHandlers.shift();
  return ((ctx, next) => {
    hookMiddleware === null || hookMiddleware === void 0 ? void 0 : hookMiddleware(ctx, () => promiseResolve(undefinedValue));
    ctx.controlLoading();
    const loadingState = ctx.proxyStates.loading;
    loadingState.v = trueValue;
    let serialPromise = next();
    for (const handler of serialHandlers) {
      serialPromise = promiseThen(serialPromise, (value) => {
        const methodItem = handler(value, ...ctx.args);
        pushItem(serialRequestMethods, methodItem);
        return methodItem.send();
      });
    }
    return serialPromise.finally(() => {
      loadingState.v = falseValue;
    });
  });
};
var useSerialRequest = (serialHandlers, config = {}) => {
  assertSerialHandlers("useSerialRequest", serialHandlers);
  const { ref, __referingObj } = statesHookHelper(promiseStatesHook());
  const methods = ref([]).current;
  const exposures = useRequest(serialHandlers[0], {
    ...config,
    __referingObj,
    middleware: serialMiddleware(serialHandlers, config.middleware, methods)
  });
  exposures.onError = decorateEvent(exposures.onError, (handler, event) => {
    event.method = methods[len(methods) - 1];
    handler(event);
  });
  return exposures;
};
var useSerialWatcher = (serialHandlers, watchingStates, config = {}) => {
  assertSerialHandlers("useSerialWatcher", serialHandlers);
  const { ref, __referingObj } = statesHookHelper(promiseStatesHook());
  const methods = ref([]).current;
  const exposures = useWatcher(serialHandlers[0], watchingStates, {
    ...config,
    __referingObj,
    middleware: serialMiddleware(serialHandlers, config.middleware, methods)
  });
  exposures.onError = decorateEvent(exposures.onError, (handler, event) => {
    event.method = methods[len(methods) - 1];
    handler(event);
  });
  return exposures;
};
var STR_VALUE_OF = "valueOf";
var DEFAULT_QUEUE_NAME = "default";
var BEHAVIOR_SILENT = "silent";
var BEHAVIOR_QUEUE = "queue";
var BEHAVIOR_STATIC = "static";
var vDataIdCollectBasket;
var setVDataIdCollectBasket = (value) => {
  vDataIdCollectBasket = value;
};
var dependentAlovaInstance;
var setDependentAlova = (alovaInst) => {
  dependentAlovaInstance = alovaInst;
};
var customSerializers = {};
var setCustomSerializers = (serializers = {}) => {
  customSerializers = serializers;
};
var silentFactoryStatus = 0;
var setSilentFactoryStatus = (status) => {
  silentFactoryStatus = status;
};
var queueRequestWaitSetting = [];
var setQueueRequestWaitSetting = (requestWaitSetting = 0) => {
  queueRequestWaitSetting = isArray(requestWaitSetting) ? requestWaitSetting : [
    {
      queue: DEFAULT_QUEUE_NAME,
      wait: requestWaitSetting
    }
  ];
};
var BootEventKey = Symbol("GlobalSQBoot");
var BeforeEventKey = Symbol("GlobalSQBefore");
var SuccessEventKey = Symbol("GlobalSQSuccess");
var ErrorEventKey = Symbol("GlobalSQError");
var FailEventKey$1 = Symbol("GlobalSQFail");
var globalSQEventManager = createEventManager();
var silentAssert = createAssert("useSQRequest");
async function updateState(matcher, handleUpdate) {
  let updated = falseValue;
  if (matcher) {
    const { update } = promiseStatesHook();
    const methodKey = getMethodInternalKey(matcher);
    const { id } = getContext(matcher);
    const hookInstances = getStateCache(id, methodKey);
    const updateStateCollection = isFn(handleUpdate) ? { data: handleUpdate } : handleUpdate;
    const updatePromises = mapItem(hookInstances, async (hookInstance) => {
      let updatedDataColumnData = undefinedValue;
      if (hookInstance) {
        const { ms: mergedStates, ro: referingObject } = hookInstance;
        forEach(objectKeys(updateStateCollection), (stateName) => {
          coreAssert(stateName in mergedStates, `state named \`${stateName}\` is not found`);
          const targetStateProxy = mergedStates[stateName];
          let updatedData = updateStateCollection[stateName](targetStateProxy.v);
          updatedData = isArray(updatedData) ? [...updatedData] : isObject(updatedData) ? { ...updatedData } : updatedData;
          if (stateName === "data") {
            updatedDataColumnData = updatedData;
          }
          update(updatedData, mergedStates[stateName].s, stateName, referingObject);
        });
      }
      if (updatedDataColumnData !== undefinedValue) {
        await setCache(matcher, updatedDataColumnData);
      }
    });
    if (len(updatePromises) > 0) {
      await PromiseCls.all(updatePromises);
      updated = trueValue;
    }
  }
  return updated;
}
var dateSerializer = {
  forward: (data) => instanceOf(data, Date) ? data.getTime() : undefinedValue,
  backward: (ts) => newInstance(Date, ts)
};
var regexpSerializer = {
  forward: (data) => instanceOf(data, RegExp) ? data.source : void 0,
  backward: (source) => newInstance(RegExp, source)
};
var createSerializerPerformer = (customSerializers2 = {}) => {
  const serializers = {
    date: dateSerializer,
    regexp: regexpSerializer,
    ...customSerializers2
  };
  const serialize = (payload) => {
    if (isObject(payload)) {
      const { data } = walkObject({ data: payload }, (value) => {
        let finallyApplySerializerName = undefinedValue;
        const serializedValue = objectKeys(serializers).reduce((currentValue, serializerName) => {
          if (!finallyApplySerializerName) {
            const serializedValueItem = serializers[serializerName].forward(currentValue);
            if (serializedValueItem !== undefinedValue) {
              finallyApplySerializerName = serializerName;
              currentValue = serializedValueItem;
            }
          }
          return currentValue;
        }, value);
        const toStringTag = ObjectCls.prototype.toString.call(value);
        if (toStringTag === "[object Object]") {
          value = { ...value };
        } else if (isArray(value)) {
          value = [...value];
        }
        return finallyApplySerializerName !== undefinedValue ? [finallyApplySerializerName, serializedValue] : value;
      });
      payload = data;
    }
    return payload;
  };
  const deserialize = (payload) => {
    if (isObject(payload)) {
      return walkObject({ data: payload }, (value) => {
        if (isArray(value) && len(value) === 2) {
          const foundSerializer = serializers[value[0]];
          value = foundSerializer ? foundSerializer.backward(value[1]) : value;
        }
        return value;
      }, falseValue).data;
    }
    return payload;
  };
  return {
    serialize,
    deserialize
  };
};
var symbolVDataId = Symbol("vdid");
var symbolOriginal = Symbol("original");
var regVDataId = /\[vd:([0-9a-z]+)\]/;
var vDataCollectUnified = (target) => {
  const vDataId = target === null || target === void 0 ? void 0 : target[symbolVDataId];
  vDataId && vDataIdCollectBasket && (vDataIdCollectBasket[vDataId] = undefinedValue);
};
var stringifyVData = (target, returnOriginalIfNotVData = trueValue) => {
  vDataCollectUnified(target);
  const vDataIdRaw = target === null || target === void 0 ? void 0 : target[symbolVDataId];
  const vDataId = vDataIdRaw ? `[vd:${vDataIdRaw}]` : undefinedValue;
  return vDataId || (returnOriginalIfNotVData ? target : undefinedValue);
};
function stringifyWithThis() {
  return stringifyVData(this);
}
var Null = function Null2() {
};
Null.prototype = ObjectCls.create(nullValue, {
  [STR_VALUE_OF]: valueObject(stringifyWithThis)
});
var Undefined = function Undefined2() {
};
Undefined.prototype = ObjectCls.create(nullValue, {
  [STR_VALUE_OF]: valueObject(stringifyWithThis)
});
var createVirtualResponse = (structure, vDataId = uuid()) => {
  const transform2VData = (value, vDataIdInner = uuid()) => {
    if (value === nullValue) {
      value = newInstance(Null);
    } else if (value === undefinedValue) {
      value = newInstance(Undefined);
    } else {
      const newValue = ObjectCls(value);
      defineProperty(newValue, STR_VALUE_OF, stringifyWithThis);
      defineProperty(newValue, symbolOriginal, value);
      value = newValue;
    }
    defineProperty(value, symbolVDataId, vDataIdInner);
    return value;
  };
  const virtualResponse = transform2VData(structure, vDataId);
  if (isPlainObject(virtualResponse) || isArray(virtualResponse)) {
    walkObject(virtualResponse, (value) => transform2VData(value));
  }
  return virtualResponse;
};
var dehydrateVDataUnified = (target, deepDehydrate = trueValue) => {
  const dehydrateItem = (value) => {
    vDataCollectUnified(value);
    if (value === null || value === void 0 ? void 0 : value[symbolVDataId]) {
      if (instanceOf(value, Undefined)) {
        value = undefinedValue;
      } else if (instanceOf(value, Null)) {
        value = nullValue;
      } else if (instanceOf(value, Number) || instanceOf(value, String) || instanceOf(value, Boolean)) {
        value = value[symbolOriginal];
      }
    }
    return value;
  };
  const newTarget = dehydrateItem(target);
  if (deepDehydrate && (isObject(newTarget) || isArray(newTarget))) {
    walkObject(newTarget, (value) => dehydrateItem(value));
  }
  return newTarget;
};
var dehydrateVData = (target) => dehydrateVDataUnified(target);
var vDataKey = "__$k";
var vDataValueKey = "__$v";
var getAlovaStorage = () => {
  silentAssert(!!dependentAlovaInstance, "alova instance is not found, Do you forget to set `alova` or call `bootSilentFactory`?");
  return dependentAlovaInstance.l2Cache;
};
var serializerPerformer = undefinedValue;
var silentMethodIdQueueMapStorageKey = "alova.SQ";
var silentMethodStorageKeyPrefix = "alova.SM.";
var storageSetItem = async (key, payload) => {
  const storage = getAlovaStorage();
  if (isObject(payload)) {
    payload = walkObject(isArray(payload) ? [...payload] : { ...payload }, (value, key2, parent) => {
      var _a;
      if (key2 === vDataValueKey && parent[vDataKey]) {
        return value;
      }
      if (key2 === "context" && ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name) === "Alova") {
        return undefinedValue;
      }
      const vDataId = value === null || value === void 0 ? void 0 : value[symbolVDataId];
      let primitiveValue = dehydrateVDataUnified(value, falseValue);
      const toStringTag = globalToString(primitiveValue);
      if (toStringTag === "[object Object]") {
        value = { ...value };
        primitiveValue = {};
      } else if (isArray(value)) {
        value = [...value];
        primitiveValue = [];
      }
      if (vDataId) {
        const valueWithVData = {
          [vDataKey]: vDataId,
          // For objects and arrays, all their internal properties will be put to the outside through `...value`, so the internal ones do not need to be traversed and converted.
          // Therefore, empty the array or object to avoid repeated conversions and contamination of the original object.
          [vDataValueKey]: primitiveValue,
          ...value
        };
        if (instanceOf(value, String)) {
          for (let i = 0; i < len(value); i += 1) {
            valueWithVData === null || valueWithVData === void 0 ? true : delete valueWithVData[i];
          }
        }
        value = valueWithVData;
      }
      return value;
    });
  }
  serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);
  await storage.set(key, serializerPerformer.serialize(payload));
};
var storageGetItem = async (key) => {
  const storagedResponse = await getAlovaStorage().get(key);
  serializerPerformer = serializerPerformer || createSerializerPerformer(customSerializers);
  return isObject(storagedResponse) ? walkObject(serializerPerformer.deserialize(storagedResponse), (value) => {
    if (isObject(value) && (value === null || value === void 0 ? void 0 : value[vDataKey])) {
      const vDataId = value[vDataKey];
      const vDataValue = createVirtualResponse(value[vDataValueKey], vDataId);
      forEach(objectKeys(value), (key2) => {
        if (!includes([vDataKey, vDataValueKey], key2)) {
          vDataValue[key2] = value[key2];
        }
      });
      value = vDataValue;
    }
    return value;
  }, falseValue) : storagedResponse;
};
var storageRemoveItem = async (key) => {
  await getAlovaStorage().remove(key);
};
var persistSilentMethod = (silentMethodInstance) => storageSetItem(silentMethodStorageKeyPrefix + silentMethodInstance.id, silentMethodInstance);
var push2PersistentSilentQueue = async (silentMethodInstance, queueName) => {
  await persistSilentMethod(silentMethodInstance);
  const silentMethodIdQueueMap = await storageGetItem(silentMethodIdQueueMapStorageKey) || {};
  const currentQueue = silentMethodIdQueueMap[queueName] = silentMethodIdQueueMap[queueName] || [];
  pushItem(currentQueue, silentMethodInstance.id);
  await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);
};
var spliceStorageSilentMethod = async (queueName, targetSilentMethodId, newSilentMethod) => {
  const silentMethodIdQueueMap = await storageGetItem(silentMethodIdQueueMapStorageKey) || {};
  const currentQueue = silentMethodIdQueueMap[queueName] || [];
  const index = currentQueue.findIndex((id) => id === targetSilentMethodId);
  if (index >= 0) {
    if (newSilentMethod) {
      splice(currentQueue, index, 1, newSilentMethod.id);
      await persistSilentMethod(newSilentMethod);
    } else {
      splice(currentQueue, index, 1);
    }
    await storageRemoveItem(silentMethodStorageKeyPrefix + targetSilentMethodId);
    len(currentQueue) <= 0 && delete silentMethodIdQueueMap[queueName];
    if (len(objectKeys(silentMethodIdQueueMap)) > 0) {
      await storageSetItem(silentMethodIdQueueMapStorageKey, silentMethodIdQueueMap);
    } else {
      await storageRemoveItem(silentMethodIdQueueMapStorageKey);
    }
  }
};
var silentQueueMap = {};
var merge2SilentQueueMap = (queueMap) => {
  forEach(objectKeys(queueMap), (targetQueueName) => {
    const currentQueue = silentQueueMap[targetQueueName] = silentQueueMap[targetQueueName] || [];
    pushItem(currentQueue, ...queueMap[targetQueueName]);
  });
};
var deepReplaceVData = (target, vDataResponse) => {
  const replaceVData = (value) => {
    const vData = stringifyVData(value);
    if (vData in vDataResponse) {
      return vDataResponse[vData];
    }
    if (isString(value)) {
      return value.replace(newInstance(RegExpCls, regVDataId.source, "g"), (mat) => mat in vDataResponse ? vDataResponse[mat] : mat);
    }
    return value;
  };
  if (isObject(target) && !stringifyVData(target, falseValue)) {
    walkObject(target, replaceVData);
  } else {
    target = replaceVData(target);
  }
  return target;
};
var updateQueueMethodEntities = (vDataResponse, targetQueue) => PromiseCls.all(mapItem(targetQueue, async (silentMethodItem) => {
  deepReplaceVData(silentMethodItem.entity, vDataResponse);
  silentMethodItem.cache && await persistSilentMethod(silentMethodItem);
}));
var replaceVirtualResponseWithResponse = (virtualResponse, response) => {
  let vDataResponse = {};
  const vDataId = stringifyVData(virtualResponse, falseValue);
  vDataId && (vDataResponse[vDataId] = response);
  if (isObject(virtualResponse)) {
    for (const i in virtualResponse) {
      vDataResponse = {
        ...vDataResponse,
        ...replaceVirtualResponseWithResponse(virtualResponse[i], response === null || response === void 0 ? void 0 : response[i])
      };
    }
  }
  return vDataResponse;
};
var setSilentMethodActive = (silentMethodInstance, active) => {
  if (active) {
    silentMethodInstance.active = active;
  } else {
    delete silentMethodInstance.active;
  }
};
var defaultBackoffDelay = 1e3;
var bootSilentQueue = (queue, queueName) => {
  const emitWithRequestDelay = (queueName2) => {
    const nextSilentMethod = queue[0];
    if (nextSilentMethod) {
      const targetSetting = queueRequestWaitSetting.find(({ queue: queue2 }) => instanceOf(queue2, RegExpCls) ? regexpTest(queue2, queueName2) : queue2 === queueName2);
      const callback = () => queue[0] && silentMethodRequest(queue[0]);
      const delay = (targetSetting === null || targetSetting === void 0 ? void 0 : targetSetting.wait) ? sloughConfig(targetSetting.wait, [nextSilentMethod, queueName2]) : 0;
      delay && delay > 0 ? setTimeoutFn(callback, delay) : callback();
    }
  };
  const silentMethodRequest = (silentMethodInstance, retryTimes = 0) => {
    setSilentMethodActive(silentMethodInstance, trueValue);
    const { cache, id, behavior, entity, retryError = /.*/, maxRetryTimes = 0, backoff = { delay: defaultBackoffDelay }, resolveHandler = noop, rejectHandler = noop, emitter: methodEmitter, handlerArgs = [], virtualResponse, force } = silentMethodInstance;
    globalSQEventManager.emit(BeforeEventKey, newInstance(GlobalSQEvent, behavior, entity, silentMethodInstance, queueName, retryTimes));
    promiseThen(entity.send(force), async (data) => {
      shift(queue);
      cache && await spliceStorageSilentMethod(queueName, id);
      resolveHandler(data);
      if (behavior === BEHAVIOR_SILENT) {
        const vDataResponse = replaceVirtualResponseWithResponse(virtualResponse, data);
        const { targetRefMethod, updateStates } = silentMethodInstance;
        if (instanceOf(targetRefMethod, Method) && updateStates && len(updateStates) > 0) {
          const updateStateCollection = {};
          forEach(updateStates, (stateName) => {
            updateStateCollection[stateName] = (dataRaw) => deepReplaceVData(dataRaw, vDataResponse);
          });
          const updated = updateState(targetRefMethod, updateStateCollection);
          if (!updated) {
            await setCache(targetRefMethod, (dataRaw) => deepReplaceVData(dataRaw, vDataResponse));
          }
        }
        await updateQueueMethodEntities(vDataResponse, queue);
        globalSQEventManager.emit(SuccessEventKey, newInstance(GlobalSQSuccessEvent, behavior, entity, silentMethodInstance, queueName, retryTimes, data, vDataResponse));
      }
      setSilentMethodActive(silentMethodInstance, falseValue);
      emitWithRequestDelay(queueName);
    }, (reason) => {
      if (behavior !== BEHAVIOR_SILENT) {
        shift(queue);
        rejectHandler(reason);
      } else {
        const runGlobalErrorEvent = (retryDelay) => globalSQEventManager.emit(ErrorEventKey, newInstance(GlobalSQErrorEvent, behavior, entity, silentMethodInstance, queueName, retryTimes, reason, retryDelay));
        const { name: errorName = "", message: errorMsg = "" } = reason || {};
        let regRetryErrorName;
        let regRetryErrorMsg;
        if (instanceOf(retryError, RegExp)) {
          regRetryErrorMsg = retryError;
        } else if (isObject(retryError)) {
          regRetryErrorName = retryError.name;
          regRetryErrorMsg = retryError.message;
        }
        const matchRetryError = regRetryErrorName && regexpTest(regRetryErrorName, errorName) || regRetryErrorMsg && regexpTest(regRetryErrorMsg, errorMsg);
        if (retryTimes < maxRetryTimes && matchRetryError) {
          const retryDelay = delayWithBackoff(backoff, retryTimes + 1);
          runGlobalErrorEvent(retryDelay);
          setTimeoutFn(
            () => {
              retryTimes += 1;
              silentMethodRequest(silentMethodInstance, retryTimes);
              methodEmitter.emit("retry", newInstance(ScopedSQRetryEvent, behavior, entity, silentMethodInstance, handlerArgs, retryTimes, retryDelay));
            },
            // When there are still retry times, use timeout as the next request time.
            retryDelay
          );
        } else {
          setSilentFactoryStatus(2);
          runGlobalErrorEvent();
          methodEmitter.emit("fallback", newInstance(ScopedSQErrorEvent, behavior, entity, silentMethodInstance, handlerArgs, reason));
          globalSQEventManager.emit(FailEventKey$1, newInstance(GlobalSQFailEvent, behavior, entity, silentMethodInstance, queueName, retryTimes, reason));
        }
      }
      setSilentMethodActive(silentMethodInstance, falseValue);
    });
  };
  emitWithRequestDelay(queueName);
};
var pushNewSilentMethod2Queue = async (silentMethodInstance, cache, targetQueueName = DEFAULT_QUEUE_NAME, onBeforePush = () => []) => {
  silentMethodInstance.cache = cache;
  const currentQueue = silentQueueMap[targetQueueName] = silentQueueMap[targetQueueName] || [];
  const isNewQueue = len(currentQueue) <= 0;
  const beforePushReturns = await Promise.all(onBeforePush());
  const isPush2Queue = !beforePushReturns.some((returns) => returns === falseValue);
  if (isPush2Queue) {
    cache && await push2PersistentSilentQueue(silentMethodInstance, targetQueueName);
    pushItem(currentQueue, silentMethodInstance);
    isNewQueue && silentFactoryStatus === 1 && bootSilentQueue(currentQueue, targetQueueName);
  }
  return isPush2Queue;
};
var getBelongQueuePosition = (silentMethodInstance) => {
  let queue = undefinedValue;
  let queueName = "";
  let position = 0;
  for (const queueNameLoop in silentQueueMap) {
    position = silentQueueMap[queueNameLoop].indexOf(silentMethodInstance);
    if (position >= 0) {
      queue = silentQueueMap[queueNameLoop];
      queueName = queueNameLoop;
      break;
    }
  }
  return [queue, queueName, position];
};
var SilentMethod = class {
  constructor(entity, behavior, emitter, id = uuid(), force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDatas) {
    const thisObj = this;
    thisObj.entity = entity;
    thisObj.behavior = behavior;
    thisObj.id = id;
    thisObj.emitter = emitter;
    thisObj.force = !!force;
    thisObj.retryError = retryError;
    thisObj.maxRetryTimes = maxRetryTimes;
    thisObj.backoff = backoff;
    thisObj.resolveHandler = resolveHandler;
    thisObj.rejectHandler = rejectHandler;
    thisObj.handlerArgs = handlerArgs;
    thisObj.vDatas = vDatas;
  }
  /**
   * Allow cache-time persistent updates to the current instance
   */
  async save() {
    this.cache && await persistSilentMethod(this);
  }
  /**
   * Replace the current instance with a new silentMethod instance in the queue
   * If there is a persistent cache, the cache will also be updated.
   * @param newSilentMethod new silentMethod instance
   */
  async replace(newSilentMethod) {
    const targetSilentMethod = this;
    silentAssert(newSilentMethod.cache === targetSilentMethod.cache, "the cache of new silentMethod must equal with this silentMethod");
    const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);
    if (queue) {
      splice(queue, position, 1, newSilentMethod);
      targetSilentMethod.cache && await spliceStorageSilentMethod(queueName, targetSilentMethod.id, newSilentMethod);
    }
  }
  /**
   * Remove the current instance. If there is persistent data, it will also be removed synchronously.
   */
  async remove() {
    const targetSilentMethod = this;
    const [queue, queueName, position] = getBelongQueuePosition(targetSilentMethod);
    if (queue) {
      splice(queue, position, 1);
      targetSilentMethod.cache && await spliceStorageSilentMethod(queueName, targetSilentMethod.id);
    }
  }
  /**
   * Set the method instance corresponding to the delayed update status and the corresponding status name
   * It will find the corresponding status data and update vData to the actual data after responding to this silentMethod
   *
   * @param method method instance
   * @param updateStateName Updated status name, the default is data, you can also set multiple
   */
  setUpdateState(method, updateStateName = "data") {
    if (method) {
      this.targetRefMethod = method;
      this.updateStates = isArray(updateStateName) ? updateStateName : [updateStateName];
    }
  }
};
var convertPayload2SilentMethod = (payload) => {
  const { id, behavior, entity, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, targetRefMethod, force } = payload;
  const deserializeMethod = (methodPayload) => {
    const { type, url, config, data } = methodPayload;
    return newInstance(Method, type, dependentAlovaInstance, url, config, data);
  };
  const silentMethodInstance = newInstance(SilentMethod, deserializeMethod(entity), behavior, createEventManager(), id, force, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs);
  silentMethodInstance.cache = trueValue;
  if (targetRefMethod) {
    silentMethodInstance.targetRefMethod = deserializeMethod(targetRefMethod);
  }
  forEach(objectKeys(payload), (key) => {
    if (!includes([
      "id",
      "behavior",
      "emitter",
      "entity",
      "retryError",
      "maxRetryTimes",
      "backoff",
      "resolveHandler",
      "rejectHandler",
      "handlerArgs",
      "targetRefMethod",
      "force"
    ], key)) {
      silentMethodInstance[key] = payload[key];
    }
  });
  return silentMethodInstance;
};
var loadSilentQueueMapFromStorage = async () => {
  const silentMethodIdQueueMap = await storageGetItem(silentMethodIdQueueMapStorageKey) || {};
  const silentQueueMap2 = {};
  const readingPromises = [];
  forEach(objectKeys(silentMethodIdQueueMap), (queueName) => {
    const currentQueue = silentQueueMap2[queueName] = silentQueueMap2[queueName] || [];
    pushItem(readingPromises, ...mapItem(silentMethodIdQueueMap[queueName], async (silentMethodId) => {
      const serializedSilentMethodPayload = await storageGetItem(silentMethodStorageKeyPrefix + silentMethodId);
      serializedSilentMethodPayload && pushItem(currentQueue, convertPayload2SilentMethod(serializedSilentMethodPayload));
    }));
  });
  await PromiseCls.all(readingPromises);
  return silentQueueMap2;
};
var onSilentSubmitBoot = (handler) => globalSQEventManager.on(BootEventKey, handler);
var onSilentSubmitSuccess = (handler) => globalSQEventManager.on(SuccessEventKey, handler);
var onSilentSubmitError = (handler) => globalSQEventManager.on(ErrorEventKey, handler);
var onSilentSubmitFail = (handler) => globalSQEventManager.on(FailEventKey$1, handler);
var onBeforeSilentSubmit = (handler) => globalSQEventManager.on(BeforeEventKey, handler);
var bootSilentFactory = (options) => {
  if (silentFactoryStatus === 0) {
    const { alova, delay = 500 } = options;
    setDependentAlova(alova);
    setCustomSerializers(options.serializers);
    setQueueRequestWaitSetting(options.requestWait);
    setTimeoutFn(async () => {
      merge2SilentQueueMap(await loadSilentQueueMapFromStorage());
      forEach(objectKeys(silentQueueMap), (queueName) => {
        bootSilentQueue(silentQueueMap[queueName], queueName);
      });
      setSilentFactoryStatus(1);
      globalSQEventManager.emit(BootEventKey, undefinedValue);
    }, delay);
  }
};
var currentSilentMethod = undefinedValue;
var createSilentQueueMiddlewares = (handler, config) => {
  const { behavior = "queue", queue = DEFAULT_QUEUE_NAME, retryError, maxRetryTimes, backoff } = config || {};
  const eventEmitter = createEventManager();
  let handlerArgs;
  let behaviorFinally;
  let queueFinally = DEFAULT_QUEUE_NAME;
  let forceRequest = falseValue;
  let silentMethodInstance;
  const createMethod = (...args) => {
    silentAssert(isFn(handler), "method handler must be a function. eg. useSQRequest(() => method)");
    setVDataIdCollectBasket({});
    handlerArgs = args;
    return handler(...args);
  };
  const decorateRequestEvent = (requestExposure) => {
    requestExposure.onSuccess = decorateEvent(requestExposure.onSuccess, (handler2, event) => {
      currentSilentMethod = silentMethodInstance;
      handler2(newInstance(ScopedSQSuccessEvent, behaviorFinally, event.method, silentMethodInstance, event.args, event.data));
    });
    requestExposure.onError = decorateEvent(requestExposure.onError, (handler2, event) => {
      handler2(newInstance(ScopedSQErrorEvent, behaviorFinally, event.method, silentMethodInstance, event.args, event.error));
    });
    requestExposure.onComplete = decorateEvent(requestExposure.onComplete, (handler2, event) => {
      handler2(newInstance(ScopedSQCompleteEvent, behaviorFinally, event.method, silentMethodInstance, event.args, event.status, event.data, event.error));
    });
  };
  const middleware = ({ method, args, cachedResponse, proxyStates, config: config2 }, next) => {
    const { silentDefaultResponse, vDataCaptured, force = falseValue } = config2;
    const baseEvent = AlovaEventBase.spawn(method, args);
    behaviorFinally = sloughConfig(behavior, [baseEvent]);
    queueFinally = sloughConfig(queue, [baseEvent]);
    forceRequest = sloughConfig(force, [baseEvent]);
    const resetCollectBasket = () => {
      setVDataIdCollectBasket(handlerArgs = undefinedValue);
    };
    if (isFn(vDataCaptured)) {
      let hasVData = vDataIdCollectBasket && len(objectKeys(vDataIdCollectBasket)) > 0;
      if (!hasVData) {
        const { url, data } = method;
        const { params, headers } = getConfig(method);
        walkObject({ url, params, data, headers }, (value) => {
          if (!hasVData && (stringifyVData(value, falseValue) || regexpTest(regVDataId, value))) {
            hasVData = trueValue;
          }
          return value;
        });
      }
      const customResponse = hasVData ? vDataCaptured(method) : undefinedValue;
      if (customResponse !== undefinedValue) {
        resetCollectBasket();
        return promiseResolve(customResponse);
      }
    }
    if (behaviorFinally !== BEHAVIOR_STATIC) {
      const createSilentMethodPromise = () => {
        const queueResolvePromise = newInstance(PromiseCls, (resolveHandler, rejectHandler) => {
          silentMethodInstance = newInstance(SilentMethod, method, behaviorFinally, eventEmitter, undefinedValue, !!forceRequest, retryError, maxRetryTimes, backoff, resolveHandler, rejectHandler, handlerArgs, vDataIdCollectBasket && objectKeys(vDataIdCollectBasket));
          resetCollectBasket();
        });
        promiseThen(promiseResolve(undefinedValue), async () => {
          const createPushEvent = () => newInstance(ScopedSQEvent, behaviorFinally, method, silentMethodInstance, args);
          const isPushed = await pushNewSilentMethod2Queue(
            silentMethodInstance,
            // After the onFallback event is bound, even the silent behavior mode is no longer stored.
            // onFallback will be called synchronously, so it needs to be determined asynchronously whether there are fallbackHandlers
            len(eventEmitter.eventMap.fallback || []) <= 0 && behaviorFinally === BEHAVIOR_SILENT,
            queueFinally,
            // Execute the callback before putting it into the queue. If false is returned, it will prevent putting it into the queue.
            () => eventEmitter.emit("beforePushQueue", createPushEvent())
          );
          isPushed && eventEmitter.emit("pushedQueue", createPushEvent());
        });
        return queueResolvePromise;
      };
      if (behaviorFinally === BEHAVIOR_QUEUE) {
        const needSendRequest = forceRequest || !cachedResponse;
        if (needSendRequest) {
          proxyStates.loading.v = trueValue;
        }
        return needSendRequest ? createSilentMethodPromise() : promiseThen(promiseResolve(cachedResponse));
      }
      const silentMethodPromise = createSilentMethodPromise();
      const virtualResponse = silentMethodInstance.virtualResponse = createVirtualResponse(isFn(silentDefaultResponse) ? silentDefaultResponse() : undefinedValue);
      promiseThen(silentMethodPromise, (realResponse) => {
        proxyStates.data.v = realResponse;
      });
      return promiseResolve(virtualResponse);
    }
    resetCollectBasket();
    return next();
  };
  return {
    c: createMethod,
    m: middleware,
    d: decorateRequestEvent,
    // event binding function
    b: {
      /**
       * Bind fallback event
       * @param handler Fallback event callback
       */
      onFallback: (handler2) => {
        eventEmitter.on("fallback", handler2);
      },
      /**
       * Event before binding to queue
       * @param handler Event callback before enqueuing
       */
      onBeforePushQueue: (handler2) => {
        eventEmitter.on("beforePushQueue", handler2);
      },
      /**
       * Event after binding to queue
       * @param handler Event callback after being queued
       */
      onPushedQueue: (handler2) => {
        eventEmitter.on("pushedQueue", handler2);
      },
      /**
       * retry event
       * @param handler Retry event callback
       */
      onRetry: (handler2) => {
        eventEmitter.on("retry", handler2);
      }
    }
  };
};
function useSQRequest(handler, config = {}) {
  const { exposeProvider, __referingObj: referingObj } = statesHookHelper(promiseStatesHook());
  const { middleware = noop } = config;
  const { c: methodCreateHandler, m: silentMiddleware, b: binders, d: decorateEvent2 } = createSilentQueueMiddlewares(handler, config);
  const states = useRequest(methodCreateHandler, {
    ...config,
    __referingObj: referingObj,
    middleware: (ctx, next) => {
      const silentMidPromise = silentMiddleware(ctx, next);
      middleware(ctx, () => silentMidPromise);
      return silentMidPromise;
    }
  });
  decorateEvent2(states);
  return exposeProvider({
    ...states,
    ...binders
  });
}
var equals = (prevValue, nextValue) => {
  if (prevValue === nextValue) {
    return trueValue;
  }
  return stringifyVData(prevValue) === stringifyVData(nextValue);
};
var filterSilentMethods = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => {
  const matchSilentMethods = (targetQueue = []) => targetQueue.filter((silentMethodItem) => {
    if (methodNameMatcher === undefinedValue) {
      return trueValue;
    }
    const name = getConfig(silentMethodItem.entity).name || "";
    const retain = instanceOf(methodNameMatcher, RegExp) ? regexpTest(methodNameMatcher, name) : name === methodNameMatcher;
    return retain && (filterActive ? silentMethodItem.active : trueValue);
  });
  return [
    ...matchSilentMethods(silentQueueMap[queueName]),
    // If the silent factory is not currently started, you also need to match the silent methods in the persistent storage.
    ...silentFactoryStatus === 0 ? matchSilentMethods((await loadSilentQueueMapFromStorage())[queueName]) : []
  ];
};
var getSilentMethod = async (methodNameMatcher, queueName = DEFAULT_QUEUE_NAME, filterActive = falseValue) => (await filterSilentMethods(methodNameMatcher, queueName, filterActive))[0];
var isVData = (target) => !!stringifyVData(target, falseValue) || regexpTest(regVDataId, target);
var updateStateEffect = async (matcher, handleUpdate) => {
  if (currentSilentMethod) {
    currentSilentMethod.setUpdateState(matcher, isFn(updateState) ? undefinedValue : objectKeys(updateState));
    await currentSilentMethod.save();
  }
  return updateState(matcher, handleUpdate);
};
var BaseEvent = class {
  constructor(type, eventInitDict = {}) {
    var _a, _b, _c;
    this.cancelBubble = falseValue;
    this.currentTarget = nullValue;
    this.defaultPrevented = falseValue;
    this.eventPhase = 0;
    this.isTrusted = falseValue;
    this.returnValue = trueValue;
    this.srcElement = nullValue;
    this.target = nullValue;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.type = type;
    this.bubbles = (_a = eventInitDict.bubbles) !== null && _a !== void 0 ? _a : false;
    this.cancelable = (_b = eventInitDict.cancelable) !== null && _b !== void 0 ? _b : false;
    this.composed = (_c = eventInitDict.composed) !== null && _c !== void 0 ? _c : false;
    this.timeStamp = Date.now();
  }
  // Event 
  preventDefault() {
    if (this.cancelable) {
      this.defaultPrevented = true;
    }
  }
  stopImmediatePropagation() {
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  composedPath() {
    return [];
  }
  initEvent(type, bubbles, cancelable) {
  }
};
BaseEvent.NONE = 0;
BaseEvent.CAPTURING_PHASE = 1;
BaseEvent.AT_TARGET = 2;
BaseEvent.BUBBLING_PHASE = 3;
var EventConstructor = typeof Event !== "undefined" ? Event : BaseEvent;
var EventSourceFetchEvent = class extends EventConstructor {
  constructor(type, eventInitDict) {
    super(type, {
      bubbles: trueValue,
      cancelable: trueValue,
      composed: trueValue
    });
    this.data = eventInitDict.data;
    this.lastEventId = eventInitDict.lastEventId;
    this.origin = eventInitDict.origin || "";
    this.error = eventInitDict.error;
  }
};
var AlovaSSEEvent = class extends AlovaEventBase {
  constructor(base, eventSource) {
    super(base.method, base.args);
    this.eventSource = eventSource;
  }
};
var AlovaSSEErrorEvent = class extends AlovaSSEEvent {
  constructor(base, error) {
    super(base, base.eventSource);
    this.error = error;
  }
};
var AlovaSSEMessageEvent = class extends AlovaSSEEvent {
  constructor(base, data) {
    super(base, base.eventSource);
    this.data = data;
  }
};
var assert$4 = createAssert("EventSourceFetch");
var EventSourceFetch = class _EventSourceFetch {
  /**
   * Creates a new EventSourceFetch instance
   *
   * @param url The URL to connect to
   * @param options Configuration options (includes all fetch options plus EventSource specific options)
   */
  constructor(url, reconnectTime, options = {}) {
    this.CONNECTING = 0;
    this.OPEN = 1;
    this.CLOSED = 2;
    this.onopen = null;
    this.onmessage = null;
    this.onerror = null;
    this._listeners = {};
    this._reconnectTime = null;
    this._controller = null;
    this._lastEventId = "";
    this._origin = "";
    this.url = url;
    this.readyState = _EventSourceFetch.CONNECTING;
    this._options = { ...options };
    this._reconnectTime = reconnectTime;
    const urlObj = newInstance(URL, url, window.location.href);
    this._origin = urlObj.origin;
    if (url) {
      setTimeoutFn(() => this._connect());
    }
  }
  /**
   * Adds an event listener for the specified event
   *
   * @param type Event type to listen for
   * @param listener Function or object to call when event is received
   * @param options EventListener options
   */
  addEventListener(type, listener) {
    this._listeners[type] = this._listeners[type] || [];
    const existing = this._listeners[type].find((l) => l === listener || isObject(l) && isObject(listener) && (l === null || l === void 0 ? void 0 : l.handleEvent) === listener.handleEvent);
    if (!existing) {
      this._listeners[type].push(listener);
    }
  }
  /**
   * Removes an event listener for the specified event
   *
   * @param type Event type to remove listener from
   * @param listener Function to remove
   * @param options EventListener options
   */
  removeEventListener(type, listener) {
    if (!listener || !this._listeners[type])
      return;
    this._listeners[type] = filterItem(this._listeners[type], (l) => l !== listener && !(typeof l === "object" && typeof listener === "object" && (l === null || l === void 0 ? void 0 : l.handleEvent) === listener.handleEvent));
  }
  /**
   * Dispatches an event
   *
   * @param event Event to dispatch
   * @returns Whether preventDefault was called
   */
  dispatchEvent(event) {
    if (!(event instanceof EventSourceFetchEvent)) {
      return trueValue;
    }
    const listeners = this._listeners[event.type] || [];
    for (const listener of listeners) {
      if (isFn(listener)) {
        listener(event);
      } else if (listener && isFn(listener.handleEvent)) {
        listener.handleEvent(event);
      }
    }
    const handlerName = `on${event.type}`;
    const handler = this[handlerName];
    if (isFn(handler)) {
      handler(event);
    }
    return !event.defaultPrevented;
  }
  /**
   * Closes the connection
   */
  close() {
    if (this.readyState === _EventSourceFetch.CLOSED) {
      return;
    }
    this.readyState = _EventSourceFetch.CLOSED;
    this._dispatchEvent("close", "");
    if (this._controller) {
      this._controller.abort();
      this._controller = null;
    }
  }
  /**
   * Establishes connection to the event source
   */
  _connect() {
    if (this.readyState === _EventSourceFetch.CLOSED) {
      return;
    }
    this._controller = newInstance(AbortController);
    const options = this._options;
    const headers = options.headers || {};
    const accept = ["Accept", "text/event-stream"];
    const lastEventIdKey = "Last-Event-ID";
    const lastEventId = this._lastEventId;
    if (isArray(headers)) {
      pushItem(headers, accept);
      lastEventId && pushItem(headers, [lastEventIdKey, lastEventId]);
    } else if (instanceOf(headers, Headers)) {
      headers.append(accept[0], accept[1]);
      lastEventId && headers.append(lastEventIdKey, lastEventId);
    } else if (isObject(headers)) {
      const [acceptHeaderKey, acceptHeaderValue] = accept;
      headers[acceptHeaderKey] = acceptHeaderValue;
      lastEventId && (headers[lastEventIdKey] = lastEventId);
    }
    const fetchOptions = {
      ...options,
      headers,
      signal: this._controller.signal
    };
    fetch(this.url, fetchOptions).then((response) => {
      assert$4(response.ok, `HTTP error: ${response.status}`);
      assert$4(response.body, "ReadableStream not supported");
      const responseUrl = newInstance(URL, response.url);
      this._origin = responseUrl.origin;
      this.readyState = _EventSourceFetch.OPEN;
      this._dispatchEvent("open", "");
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      const processStream = ({ done, value }) => {
        if (done) {
          if (this.readyState !== _EventSourceFetch.CLOSED) {
            this._reconnect();
          }
          return promiseResolve();
        }
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split(/\r\n|\r|\n/);
        buffer = lines.pop() || "";
        this._processEventStream(lines);
        return reader.read().then(processStream).catch((e) => {
          if (e.name !== "AbortError" && this.readyState !== _EventSourceFetch.CLOSED) {
            this._onError(e);
          }
          return promiseResolve();
        });
      };
      return reader.read().then(processStream).catch((e) => {
        if (e.name !== "AbortError" && this.readyState !== _EventSourceFetch.CLOSED) {
          this._onError(e);
        }
      });
    }).catch((err) => {
      if (err.name !== "AbortError" && this.readyState !== _EventSourceFetch.CLOSED) {
        this._onError(err);
      }
    });
  }
  /**
   * Processes received event stream lines
   *
   * @param lines Lines received from the event stream
   */
  _processEventStream(lines) {
    let eventType = "message";
    let data = "";
    let eventId = null;
    let retry = null;
    const dispatchPendingEvent = () => {
      if (data) {
        if (data.endsWith("\n")) {
          data = data.substring(0, data.length - 1);
        }
        if (eventId !== null) {
          this._lastEventId = eventId;
        }
        if (retry !== null && this._reconnectTime === null) {
          const retryInt = parseInt(retry, 10);
          if (!Number.isNaN(retryInt)) {
            this._reconnectTime = retryInt;
          }
        }
        this._dispatchEvent(eventType, data);
      }
      eventType = "message";
      data = "";
      eventId = null;
      retry = null;
    };
    for (const line of lines) {
      if (line === "") {
        dispatchPendingEvent();
        continue;
      }
      if (line.startsWith(":")) {
        continue;
      }
      let field;
      let value;
      const colonIndex = line.indexOf(":");
      if (colonIndex === -1) {
        field = line;
        value = "";
      } else {
        field = line.slice(0, colonIndex);
        value = line.slice(colonIndex + (line[colonIndex + 1] === " " ? 2 : 1));
      }
      switch (field) {
        case "event":
          eventType = value;
          break;
        case "data":
          data = data ? `${data}
${value}` : value;
          break;
        case "id":
          if (value.includes("\0")) {
            continue;
          }
          eventId = value;
          break;
        case "retry":
          retry = value;
          break;
        default:
          throw newInstance(AlovaError, "EventSource", `EventSource: Unknown field "${field}", ignoring`);
      }
    }
  }
  /**
   * Dispatches an event
   *
   * @param type Event type
   * @param data Event data
   */
  _dispatchEvent(type, data) {
    const event = newInstance(EventSourceFetchEvent, type, {
      type,
      data,
      lastEventId: this._lastEventId,
      origin: this._origin
    });
    this.dispatchEvent(event);
  }
  /**
   * Handles errors
   *
   * @param error Error object
   */
  _onError(error) {
    const event = newInstance(EventSourceFetchEvent, "error", {
      type: "error",
      data: "",
      lastEventId: this._lastEventId,
      origin: this._origin,
      error
    });
    this.dispatchEvent(event);
    if (this.readyState !== _EventSourceFetch.CLOSED) {
      this._reconnect();
    }
  }
  /**
   * Attempts to reconnect after connection closed or error
   */
  _reconnect() {
    var _a;
    if (this._reconnectTime !== null && this._reconnectTime <= 0) {
      this.close();
      return;
    }
    if (this.readyState !== _EventSourceFetch.CLOSED) {
      this.readyState = _EventSourceFetch.CONNECTING;
      const reconnectDelay = (_a = this._reconnectTime) !== null && _a !== void 0 ? _a : 1e3;
      setTimeoutFn(() => this._connect(), reconnectDelay);
    }
  }
};
EventSourceFetch.CONNECTING = 0;
EventSourceFetch.OPEN = 1;
EventSourceFetch.CLOSED = 2;
var SSEOpenEventKey = Symbol("SSEOpen");
var SSEMessageEventKey = Symbol("SSEMessage");
var SSEErrorEventKey = Symbol("SSEError");
var SSEHookReadyState;
(function(SSEHookReadyState2) {
  SSEHookReadyState2[SSEHookReadyState2["CONNECTING"] = 0] = "CONNECTING";
  SSEHookReadyState2[SSEHookReadyState2["OPEN"] = 1] = "OPEN";
  SSEHookReadyState2[SSEHookReadyState2["CLOSED"] = 2] = "CLOSED";
})(SSEHookReadyState || (SSEHookReadyState = {}));
var errorPrefix = "useSSE";
var assert$3 = createAssert(errorPrefix);
var MessageType;
(function(MessageType2) {
  MessageType2["Open"] = "open";
  MessageType2["Error"] = "error";
  MessageType2["Message"] = "message";
  MessageType2["Close"] = "close";
})(MessageType || (MessageType = {}));
var useSSE = (handler, config = {}) => {
  const {
    initialData,
    withCredentials,
    interceptByGlobalResponded = trueValue,
    /** abortLast = trueValue, */
    immediate = falseValue,
    responseType = "text",
    reconnectionTime = null,
    ...fetchOptions
  } = config;
  const abortLast = trueValue;
  const { create, ref, onMounted, onUnmounted, objectify, exposeProvider, memorize } = statesHookHelper(promiseStatesHook());
  const usingArgs = ref([]);
  const eventSource = ref(undefinedValue);
  const sendPromiseObject = ref(undefinedValue);
  const data = create(initialData, "data");
  const readyState = create(SSEHookReadyState.CLOSED, "readyState");
  const exposedEventSource = create(undefinedValue, "eventSource");
  let methodInstance = getHandlerMethod2(handler);
  let responseUnified;
  const eventManager = createEventManager();
  const customEventMap = ref(/* @__PURE__ */ new Map());
  const onOpen = (handler2) => {
    eventManager.on(SSEOpenEventKey, handler2);
  };
  const onMessage = (handler2) => {
    eventManager.on(SSEMessageEventKey, handler2);
  };
  const onError = (handler2) => {
    eventManager.on(SSEErrorEventKey, handler2);
  };
  const responseSuccessHandler = ref($self);
  const responseErrorHandler = ref(throwFn);
  const responseCompleteHandler = ref(noop);
  const setResponseHandler = (instance) => {
    const { responded } = getOptions(instance);
    responseUnified = responded;
    if (isFn(responseUnified)) {
      responseSuccessHandler.current = responseUnified;
    } else if (responseUnified && isPlainObject(responseUnified)) {
      const { onSuccess: successHandler, onError: errorHandler, onComplete: completeHandler } = responseUnified;
      responseSuccessHandler.current = isFn(successHandler) ? successHandler : responseSuccessHandler.current;
      responseErrorHandler.current = isFn(errorHandler) ? errorHandler : responseErrorHandler.current;
      responseCompleteHandler.current = isFn(completeHandler) ? completeHandler : responseCompleteHandler.current;
    }
  };
  const handleResponseTask = async (handlerReturns) => {
    const { headers, transform: transformFn = $self } = getConfig(methodInstance);
    const returnsData = await handlerReturns;
    const transformedData = await transformFn(returnsData, headers || {});
    data.v = transformedData;
    hitCacheBySource(methodInstance);
    return transformedData;
  };
  const createSSEEvent = async (eventFrom, dataOrError) => {
    assert$3(eventSource.current, "EventSource is not initialized");
    const es = eventSource.current;
    const baseEvent = newInstance(AlovaSSEEvent, AlovaEventBase.spawn(methodInstance, usingArgs.current), es);
    if (eventFrom === MessageType.Open) {
      return baseEvent;
    }
    const globalSuccess = interceptByGlobalResponded ? responseSuccessHandler.current : $self;
    const globalError = interceptByGlobalResponded ? responseErrorHandler.current : throwFn;
    const globalFinally = interceptByGlobalResponded ? responseCompleteHandler.current : noop;
    const isStringData = isString(dataOrError);
    if (responseType === "json" && isStringData) {
      try {
        dataOrError = JSONParse(dataOrError);
      } catch (error) {
        throw newInstance(AlovaError, errorPrefix, error.message);
      }
    }
    const p = promiseFinally(promiseThen(isStringData ? promiseResolve(dataOrError) : promiseReject(dataOrError), (res) => handleResponseTask(globalSuccess(res, methodInstance)), (error) => handleResponseTask(globalError(error, methodInstance))), () => {
      globalFinally(methodInstance);
    });
    return promiseThen(
      p,
      // Get processed data (data after transform)
      (res) => newInstance(AlovaSSEMessageEvent, baseEvent, res),
      // There is an error
      (error) => new AlovaSSEErrorEvent(baseEvent, error)
    );
  };
  const sendSSEEvent = (callback) => (event) => {
    if (event.error === undefinedValue) {
      return callback(event);
    }
    return eventManager.emit(SSEErrorEventKey, event);
  };
  const onCustomEvent = (eventName, callbackHandler) => {
    var _a;
    const currentMap = customEventMap.current;
    if (!currentMap.has(eventName)) {
      const useCallbackObject = useCallback((callbacks) => {
        var _a2;
        if (callbacks.length === 0) {
          (_a2 = eventSource.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(eventName, useCallbackObject[1]);
          customEventMap.current.delete(eventName);
        }
      });
      const trigger = useCallbackObject[1];
      currentMap.set(eventName, useCallbackObject);
      (_a = eventSource.current) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, (event) => {
        promiseThen(createSSEEvent(eventName, event.data), sendSSEEvent(trigger));
      });
    }
    const [onEvent] = currentMap.get(eventName);
    return onEvent(callbackHandler);
  };
  const offCustomEvent = () => {
    customEventMap.current.forEach(([_1, _2, offTrigger]) => {
      offTrigger();
    });
  };
  const esOpen = memorize(() => {
    var _a;
    readyState.v = SSEHookReadyState.OPEN;
    promiseThen(createSSEEvent(MessageType.Open), (event) => eventManager.emit(SSEOpenEventKey, event));
    (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.resolve();
  });
  const esError = memorize((event) => {
    var _a;
    readyState.v = SSEHookReadyState.CLOSED;
    promiseThen(createSSEEvent(MessageType.Error, event.error || newInstance(Error, "SSE Error")), sendSSEEvent((event2) => eventManager.emit(SSEMessageEventKey, event2)));
    (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.resolve();
  });
  const esMessage = memorize((event) => {
    promiseThen(createSSEEvent(MessageType.Message, event.data), sendSSEEvent((event2) => eventManager.emit(SSEMessageEventKey, event2)));
  });
  const close = () => {
    const es = eventSource.current;
    if (!es) {
      return;
    }
    if (sendPromiseObject.current) {
      sendPromiseObject.current.resolve();
    }
    es.close();
    es.removeEventListener(MessageType.Open, esOpen);
    es.removeEventListener(MessageType.Error, esError);
    es.removeEventListener(MessageType.Message, esMessage);
    es.removeEventListener(MessageType.Close, close);
    readyState.v = SSEHookReadyState.CLOSED;
    customEventMap.current.forEach(([_, eventTrigger], eventName) => {
      es.removeEventListener(eventName, eventTrigger);
    });
  };
  const connect = (...args) => {
    let es = eventSource.current;
    let promiseObj = sendPromiseObject.current;
    if (es && abortLast) {
      close();
    }
    if (!promiseObj) {
      promiseObj = sendPromiseObject.current = usePromise();
      promiseObj && promiseFinally(promiseObj.promise, () => {
        promiseObj = undefinedValue;
      });
    }
    usingArgs.current = args;
    methodInstance = getHandlerMethod2(handler, args);
    setResponseHandler(methodInstance);
    const { params, headers } = getConfig(methodInstance);
    const { baseURL, url, data: data2, type } = methodInstance;
    const fullURL = buildCompletedURL(baseURL, url, params);
    const isBodyData = (data3) => isString(data3) || isSpecialRequestBody(data3);
    es = newInstance(EventSourceFetch, fullURL, reconnectionTime, {
      credentials: withCredentials ? "include" : "same-origin",
      method: type || "GET",
      headers,
      body: isBodyData(data2) ? data2 : JSONStringify(data2),
      ...fetchOptions
    });
    eventSource.current = es;
    exposedEventSource.v = es;
    readyState.v = SSEHookReadyState.CONNECTING;
    es.addEventListener(MessageType.Open, esOpen);
    es.addEventListener(MessageType.Error, esError);
    es.addEventListener(MessageType.Message, esMessage);
    es.addEventListener(MessageType.Close, close);
    customEventMap.current.forEach(([_, eventTrigger], eventName) => {
      es === null || es === void 0 ? void 0 : es.addEventListener(eventName, (event) => {
        promiseThen(createSSEEvent(eventName, event.data), sendSSEEvent(eventTrigger));
      });
    });
    return promiseObj.promise;
  };
  onUnmounted(() => {
    close();
    eventManager.off(SSEOpenEventKey);
    eventManager.off(SSEMessageEventKey);
    eventManager.off(SSEErrorEventKey);
    offCustomEvent();
  });
  onMounted(() => {
    var _a;
    if (immediate) {
      connect(...[]);
      (_a = sendPromiseObject.current) === null || _a === void 0 ? void 0 : _a.promise.catch(() => {
      });
    }
  });
  return exposeProvider({
    send: connect,
    close,
    on: onCustomEvent,
    onMessage,
    onError,
    onOpen,
    ...objectify([readyState, data, exposedEventSource])
  });
};
var assert$2 = createAssert("useUploader");
function useUploader(handler, { limit = 0, localLink, replaceSrc, mode } = {}) {
  const { create, computed, exposeProvider, ref } = statesHookHelper(promiseStatesHook());
  const eventManager = createEventManager();
  const fileList = create([], "fileList");
  const file = computed(() => fileList.v[0], [fileList], "file");
  const uploading = create(false, "uploading");
  const successCount = create(0, "successCount");
  const failCount = create(0, "failCount");
  const totalProgress = computed(() => ({
    ...fileList.v.reduce((progress, { progress: itemProgress, status }) => {
      if (status !== 0) {
        progress.total += itemProgress.total;
        progress.uploaded += itemProgress.uploaded;
      }
      return progress;
    }, {
      uploaded: 0,
      total: 0
    })
  }), [fileList], "progress");
  const error = computed(() => {
    var _a;
    return (_a = fileList.v.find((item) => item.error)) === null || _a === void 0 ? void 0 : _a.error;
  }, [fileList], "error");
  const appendFiles = async (files = {}, options = {}) => {
    var _a;
    let optionsFiles = files;
    let finallyOptions = options;
    if (!files.file && !isArray(files)) {
      finallyOptions = files;
      optionsFiles = [];
    }
    let rawFiles = isArray(optionsFiles) ? optionsFiles : [optionsFiles];
    if (len(rawFiles) <= 0) {
      rawFiles = await useUploader.selectFile(finallyOptions);
    }
    assert$2(limit <= 0 || len(fileList.v) + len(rawFiles) <= limit, `The number of files exceeds the limit of ${limit}`);
    const { converters } = useUploader;
    const convertedFiles = await PromiseCls.all(mapItem(rawFiles, async (file2) => {
      const converter = converters.find(({ is }) => is(file2));
      assert$2(converter, `Invalid file type, only ${mapItem(converters, ({ name }) => name).join(", ")} are supported, if other file needs, customize convert function with \`useUploader.convertFile.push({ is: ..., convert: ... })\``);
      const convertedFile = await converter.convert(file2);
      assert$2(convertedFile, "Failed to convert file");
      return {
        src: file2.src || (localLink ? URL.createObjectURL(convertedFile) : void 0),
        file: convertedFile,
        status: 0,
        progress: { uploaded: 0, total: convertedFile.size }
      };
    }));
    const insertPosition = (_a = finallyOptions.start) !== null && _a !== void 0 ? _a : len(fileList.v);
    const validConvertedFiles = filterItem(convertedFiles, Boolean);
    const fileListValue = [...fileList.v];
    splice(fileListValue, insertPosition, 0, ...validConvertedFiles);
    fileList.v = fileListValue;
    return len(convertedFiles);
  };
  const getTargetFiles = (positions, excludeStatuses = [1, 2], type = "upload") => {
    const assertErrorWords = {
      upload: "uploaded",
      abort: "aborted"
    }[type];
    const fileListValue = fileList.v;
    return len(positions) > 0 ? mapItem(positions, (item, i) => {
      const isItemNum = isNumber(item);
      const fileItem = isItemNum ? fileListValue[item] : item;
      const positionText = isItemNum ? `index ${item}` : `position ${i}`;
      assert$2(fileItem, `The file of ${positionText} does not exist`);
      len(excludeStatuses) > 0 && assert$2(!includes(excludeStatuses, fileItem.status) && isObject(fileItem.file), `The file of ${positionText} cannot be ${assertErrorWords}, which status is ${fileItem.status}`);
      return fileItem;
    }) : filterItem(fileListValue, (f) => !includes(excludeStatuses, f.status));
  };
  const filterFiles = (files, statuses) => filterItem(files, (file2) => len(statuses) > 0 ? includes(statuses, file2.status) : trueValue);
  const uploadingMethods = ref([]);
  const pushMethod = (file2, method) => {
    const index = fileList.v.findIndex((fileItem) => fileItem.file === file2);
    if (index > -1) {
      pushItem(uploadingMethods.current, { f: file2, m: method });
    }
  };
  const removeMethod = (method) => {
    uploadingMethods.current = filterItem(uploadingMethods.current, ({ m }) => m !== method);
  };
  const abort = (...positions) => {
    const filesToAbort = getTargetFiles(positions, [0, 2, 3], "abort");
    const abortMethods = [];
    if (len(filesToAbort) > 0) {
      forEach(filesToAbort, ({ file: file2 }) => {
        const uploadingItem = uploadingMethods.current.find(({ f }) => f === file2);
        uploadingItem && pushItem(abortMethods, uploadingItem.m);
      });
    } else {
      pushItem(abortMethods, ...mapItem(uploadingMethods.current, ({ m }) => m));
    }
    const abortMethodSet = [];
    forEach(abortMethods, (m) => {
      if (!abortMethodSet.includes(m)) {
        pushItem(abortMethodSet, m);
      }
    });
    forEach(abortMethodSet, (method) => method.abort());
  };
  const removeFiles = (...positions) => {
    const filesToRemove = getTargetFiles(positions, []);
    if (len(filesToRemove) > 0) {
      abort(...filterFiles(filesToRemove, [1]));
      fileList.v = filterItem(fileList.v, (file2) => !includes(filesToRemove, file2));
      successCount.v = len(filterFiles(fileList.v, [2]));
      failCount.v = len(filterFiles(fileList.v, [3]));
    } else {
      abort(...filterFiles(fileList.v, [1]));
      fileList.v = [];
    }
  };
  const createEvent = (method, response, error2) => {
    const baseEvent = AlovaEventBase.spawn(method, []);
    return {
      successEvent: newInstance(AlovaSuccessEvent, baseEvent, response, falseValue),
      errorEvent: newInstance(AlovaErrorEvent, baseEvent, error2),
      completeEvent: newInstance(AlovaCompleteEvent, baseEvent, error2 ? KEY_ERROR : KEY_SUCCESS, response, falseValue, error2)
    };
  };
  const updateFileStatus = (file2, status, response, error2, index = 0) => {
    file2.status = status;
    if (status === 2) {
      file2.progress.uploaded = file2.progress.total;
      if (replaceSrc) {
        const src = replaceSrc(response, index);
        if (src) {
          file2.src = src;
        }
      }
    } else if (status === 3) {
      file2.error = error2;
    }
    fileList.v = [...fileList.v];
  };
  const createBatchUploadHandler = (filesToUpload, filesData) => {
    const uploadingMethod = handler(filesData);
    uploadingMethod.onUpload((totalProgress2) => {
      forEach(filesToUpload, (file2) => {
        file2.progress.uploaded = totalProgress2.loaded * (file2.progress.total / totalProgress2.total);
      });
    });
    forEach(filesToUpload, ({ file: file2 }) => pushMethod(file2, uploadingMethod));
    return uploadingMethod.then((response) => {
      forEach(filesToUpload, (file2, i) => updateFileStatus(file2, 2, response, void 0, i));
      successCount.v = len(filterFiles(fileList.v, [2]));
      const { successEvent, completeEvent } = createEvent(uploadingMethod, response);
      eventManager.emit(KEY_SUCCESS, successEvent);
      eventManager.emit(KEY_COMPLETE, completeEvent);
      return response;
    }, (error2) => {
      forEach(filesToUpload, (file2) => updateFileStatus(file2, 3, void 0, error2));
      failCount.v = len(filterFiles(fileList.v, [3]));
      const { errorEvent, completeEvent } = createEvent(uploadingMethod, void 0, error2);
      eventManager.emit(KEY_ERROR, errorEvent);
      eventManager.emit(KEY_COMPLETE, completeEvent);
      return error2;
    }).finally(() => {
      uploading.v = false;
      removeMethod(uploadingMethod);
    });
  };
  const createEachUploadHandler = (filesToUpload) => {
    const uploadPromises = mapItem(filesToUpload, (file2, i) => {
      const uploadingMethod = handler({ file: file2.file, name: file2.file.name });
      uploadingMethod.onUpload(({ loaded, total }) => {
        forEach(filesToUpload, (file3) => {
          file3.progress.uploaded = loaded;
          file3.progress.total = total;
        });
      });
      pushMethod(file2.file, uploadingMethod);
      return uploadingMethod.then((response) => {
        updateFileStatus(file2, 2, response, undefinedValue, i);
        successCount.v += 1;
        const { successEvent, completeEvent } = createEvent(uploadingMethod, response);
        eventManager.emit(KEY_SUCCESS, successEvent);
        eventManager.emit(KEY_COMPLETE, completeEvent);
        return response;
      }, (error2) => {
        updateFileStatus(file2, 3, undefinedValue, error2);
        failCount.v += 1;
        const { errorEvent, completeEvent } = createEvent(uploadingMethod, undefinedValue, error2);
        eventManager.emit(KEY_ERROR, errorEvent);
        eventManager.emit(KEY_COMPLETE, completeEvent);
        return error2;
      }).finally(() => {
        removeMethod(uploadingMethod);
      });
    });
    return promiseFinally(PromiseCls.all(uploadPromises), () => {
      uploading.v = falseValue;
    });
  };
  const upload = async (...positions) => {
    const filesToUpload = getTargetFiles(positions);
    forEach(filesToUpload, (file2) => {
      file2.status = 1;
    });
    const filesData = mapItem(filesToUpload, ({ file: file2 }) => ({
      file: file2,
      name: file2.name
    }));
    uploading.v = trueValue;
    return mode === "batch" ? createBatchUploadHandler(filesToUpload, filesData) : createEachUploadHandler(filesToUpload);
  };
  return exposeProvider({
    fileList,
    uploading,
    file,
    progress: totalProgress,
    successCount,
    failCount,
    error,
    appendFiles,
    removeFiles,
    upload,
    abort,
    onSuccess: (handler2) => {
      eventManager.on(KEY_SUCCESS, handler2);
    },
    onError: (handler2) => {
      eventManager.on(KEY_ERROR, handler2);
    },
    onComplete: (handler2) => {
      eventManager.on(KEY_COMPLETE, handler2);
    }
  });
}
useUploader.selectFile = ({ multiple, accept } = {}) => {
  const input = document.createElement("input");
  input.type = "file";
  input.multiple = !!multiple;
  if (accept) {
    input.accept = accept;
  }
  input.click();
  return newInstance(Promise, (resolve) => {
    input.addEventListener("change", () => {
      const rawFiles = mapItem(Array.from(input.files || []), (file) => ({
        file,
        name: file.name,
        mimeType: file.type
      }));
      resolve(rawFiles);
    });
  });
};
var defaultMimeType = "text/plain";
useUploader.converters = [
  {
    name: "HTMLCanvasElement",
    is: ({ file }) => instanceOf(file, HTMLCanvasElement),
    async convert({ file, mimeType, name }) {
      const blob = await newInstance(PromiseCls, (resolve) => file === null || file === void 0 ? void 0 : file.toBlob(resolve));
      if (blob) {
        return newInstance(File, [blob], name || "image.png", {
          type: mimeType || blob.type
        });
      }
    }
  },
  {
    name: "base64",
    is: ({ file }) => isString(file),
    convert({ file = "", mimeType, name }) {
      var _a;
      assert$2(/data:.+;base64,/.test(file), "Invalid base64 string");
      const arr = file.split(",");
      const mime = (_a = arr[0].match(/:(.*?);/)) === null || _a === void 0 ? void 0 : _a[1];
      const bstr = atob(arr[1]);
      const u8arr = new Uint8Array(len(bstr));
      forEach(Array.from(bstr), (char, n) => {
        u8arr[n] = char.charCodeAt(0);
      });
      return newInstance(File, [u8arr], name || "file", {
        type: mimeType || mime || defaultMimeType
      });
    }
  },
  {
    name: "File",
    is: ({ file }) => instanceOf(file, File),
    convert({ file }) {
      return file;
    }
  },
  {
    name: "Blob",
    is: ({ file }) => instanceOf(file, Blob),
    convert({ file, name, mimeType }) {
      return newInstance(File, [file], name || "file", {
        type: mimeType || file.type || defaultMimeType
      });
    }
  },
  {
    name: "ArrayBuffer",
    is: ({ file }) => instanceOf(file, ArrayBuffer),
    convert({ file, name, mimeType }) {
      return newInstance(File, [newInstance(Blob, [file])], name || "file", {
        type: mimeType || defaultMimeType
      });
    }
  }
];
var useAutoRequest = (handler, config = {}) => {
  let notifiable = trueValue;
  const { enableFocus = trueValue, enableVisibility = trueValue, enableNetwork = trueValue, pollingTime = 0, throttle = 1e3 } = config;
  const { onMounted, onUnmounted, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());
  const states = useRequest(handler, {
    ...config,
    __referingObj: referingObject
  });
  const notify = () => {
    if (notifiable) {
      states.send();
      if (throttle > 0) {
        notifiable = falseValue;
        setTimeout(() => {
          notifiable = trueValue;
        }, throttle);
      }
    }
  };
  let offNetwork = noop;
  let offFocus = noop;
  let offVisiblity = noop;
  let offPolling = noop;
  onMounted(() => {
    if (!globalConfigMap.ssr) {
      offNetwork = enableNetwork ? useAutoRequest.onNetwork(notify, config) : offNetwork;
      offFocus = enableFocus ? useAutoRequest.onFocus(notify, config) : offFocus;
      offVisiblity = enableVisibility ? useAutoRequest.onVisibility(notify, config) : offVisiblity;
      offPolling = pollingTime > 0 ? useAutoRequest.onPolling(notify, config) : offPolling;
    }
  });
  onUnmounted(() => {
    offNetwork();
    offFocus();
    offVisiblity();
    offPolling();
  });
  return states;
};
var on = (type, handler) => {
  window.addEventListener(type, handler);
  return () => window.removeEventListener(type, handler);
};
useAutoRequest.onNetwork = (notify) => on("online", notify);
useAutoRequest.onFocus = (notify) => on("focus", notify);
useAutoRequest.onVisibility = (notify) => {
  const handle = () => document.visibilityState === "visible" && notify();
  return on("visibilitychange", handle);
};
useAutoRequest.onPolling = (notify, config) => {
  const timer = setInterval(notify, config.pollingTime);
  return () => clearInterval(timer);
};
var hookPrefix$1 = "useCaptcha";
var captchaAssert = createAssert(hookPrefix$1);
var useCaptcha = (handler, config = {}) => {
  const { initialCountdown, middleware } = config;
  captchaAssert(initialCountdown === undefinedValue || initialCountdown > 0, "initialCountdown must be greater than 0");
  const { create, ref, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());
  const countdown = create(0, "countdown");
  const requestReturned = useRequest(handler, {
    ...config,
    __referingObj: referingObject,
    immediate: falseValue,
    managedStates: objectify([countdown], "s"),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    middleware: middleware ? (ctx, next) => middleware({ ...ctx, send }, next) : undefinedValue
  });
  const timer = ref(undefinedValue);
  const send = (...args) => newInstance(PromiseCls, (resolve, reject) => {
    if (countdown.v <= 0) {
      requestReturned.send(...args).then((result) => {
        countdown.v = config.initialCountdown || 60;
        timer.current = setInterval(() => {
          countdown.v -= 1;
          if (countdown.v <= 0) {
            clearInterval(timer.current);
          }
        }, 1e3);
        resolve(result);
      }).catch((reason) => reject(reason));
    } else {
      reject(newInstance(AlovaError, hookPrefix$1, "the countdown is not over yet"));
    }
  });
  return exposeProvider({
    ...requestReturned,
    send,
    ...objectify([countdown])
  });
};
var RestoreEventKey = Symbol("FormRestore");
var getStoragedKey = (targetKey) => `alova/form-${instanceOf(targetKey, Method) ? getMethodInternalKey(targetKey) : targetKey}`;
var sharedEventManager = createEventManager();
var sharedStates = {};
var cloneFormData = (form) => {
  const shallowClone = (value) => isArray(value) ? [...value] : isPlainObject(value) ? { ...value } : value;
  return walkObject(shallowClone(form), shallowClone);
};
var useForm = (handler, config = {}) => {
  const { id: originalId } = config;
  const sharedState = originalId ? sharedStates[originalId] : undefinedValue;
  const { id, initialForm, store, resetAfterSubmiting, immediate = falseValue, middleware } = (sharedState === null || sharedState === void 0 ? void 0 : sharedState.config) || config;
  promiseStatesHook();
  const { create, ref, onMounted, onUnmounted, watch, objectify, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());
  const isStoreObject = isPlainObject(store);
  const enableStore = isStoreObject ? store.enable : store;
  const form = create(cloneFormData((sharedState === null || sharedState === void 0 ? void 0 : sharedState.form) || initialForm), "form");
  const methodHandler = handler;
  const eventManager = createEventManager();
  const initialMethod = ref(undefinedValue);
  let storageContext = sharedState === null || sharedState === void 0 ? void 0 : sharedState.l2Cache;
  if (enableStore && !(sharedState === null || sharedState === void 0 ? void 0 : sharedState.l2Cache)) {
    initialMethod.current = sloughConfig(methodHandler, [form.v]);
    storageContext = getContext(initialMethod.current).l2Cache;
  }
  const storagedKey = getStoragedKey(id || initialMethod.current || "");
  const reseting = ref(falseValue);
  const serializerPerformer2 = ref(createSerializerPerformer(isStoreObject ? store.serializers : undefinedValue));
  if (id && !sharedStates[id]) {
    sharedStates[id] = {
      form: form.v,
      l2Cache: storageContext,
      config
    };
  }
  const originalHookProvider = useRequest((...args) => methodHandler(form.v, ...args), {
    ...config,
    __referingObj: referingObject,
    // Middleware function, also supports subscriber middleware
    middleware: middleware ? (ctx, next) => middleware({
      ...ctx,
      // eslint-disable-next-line
      delegatingActions: { updateForm, reset }
    }, next) : undefinedValue,
    // 1. When persistence is required, it will be triggered after data recovery
    // 2. When there is a shared state, it means that it has been initialized before (regardless of whether there is an immediate request), and subsequent requests will no longer be automatically initiated. This is to be compatible with the issue of repeated requests when multiple forms initiate requests immediately.
    immediate: enableStore || sharedState ? falseValue : immediate
  });
  const reset = () => {
    reseting.current = trueValue;
    const clonedFormData = cloneFormData(initialForm);
    clonedFormData && (form.v = clonedFormData);
    enableStore && (storageContext === null || storageContext === void 0 ? void 0 : storageContext.remove(storagedKey));
  };
  const updateForm = (newForm) => {
    form.v = {
      ...form.v,
      ...newForm
    };
  };
  const hookProvider = exposeProvider({
    // The first parameter is fixed to form data
    ...originalHookProvider,
    ...objectify([form]),
    updateForm,
    reset,
    // Persistent data recovery event binding
    onRestore(handler2) {
      eventManager.on(RestoreEventKey, handler2);
    }
  });
  const sharedOffHandler = ref(noop);
  const { send, onSuccess } = hookProvider;
  onMounted(() => {
    if (id) {
      sharedOffHandler.current = sharedEventManager.on(id, (formData) => {
        form.v = formData;
      });
    }
    if (enableStore && storageContext && !sharedState) {
      const storagedForm = serializerPerformer2.current.deserialize(storageContext.get(storagedKey));
      if (storagedForm) {
        form.v = storagedForm;
        eventManager.emit(RestoreEventKey, undefinedValue);
      }
      immediate && send(...[]);
    }
  });
  watch([form], () => {
    if (id) {
      sharedEventManager.emit(id, form.v);
      if (sharedStates[id]) {
        sharedStates[id].form = form.v;
      }
    }
    if (reseting.current || !enableStore) {
      reseting.current = falseValue;
      return;
    }
    storageContext === null || storageContext === void 0 ? void 0 : storageContext.set(storagedKey, serializerPerformer2.current.serialize(form.v));
  });
  onUnmounted(() => {
    sharedOffHandler.current();
  });
  onSuccess(() => {
    resetAfterSubmiting && reset();
  });
  return hookProvider;
};
var RetryEventKey = Symbol("RetriableRetry");
var FailEventKey = Symbol("RetriableFail");
var hookPrefix = "useRetriableRequest";
var assert$1 = createAssert(hookPrefix);
var useRetriableRequest = (handler, config = {}) => {
  const { retry = 3, backoff = { delay: 1e3 }, middleware = noop } = config;
  const { ref: useFlag$, exposeProvider, __referingObj: referingObject } = statesHookHelper(promiseStatesHook());
  const eventManager = createEventManager();
  const retryTimes = useFlag$(0);
  const stopManuallyError = useFlag$(undefinedValue);
  const methodInstanceLastest = useFlag$(undefinedValue);
  const argsLatest = useFlag$(undefinedValue);
  const requesting = useFlag$(falseValue);
  const retryTimer = useFlag$(undefinedValue);
  const stopPromiseObj = useFlag$(usePromise());
  const emitOnFail = (method, args, error) => {
    setTimeoutFn(() => {
      eventManager.emit(FailEventKey, newInstance(RetriableFailEvent, AlovaEventBase.spawn(method, args), error, retryTimes.current));
      stopManuallyError.current = undefinedValue;
      retryTimes.current = 0;
    });
  };
  const nestedHookProvider = useRequest(handler, {
    ...config,
    __referingObj: referingObject,
    middleware(ctx, next) {
      middleware({
        ...ctx,
        delegatingActions: {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          stop
        }
      }, () => promiseResolve());
      const { proxyStates, args, send, method, controlLoading } = ctx;
      controlLoading();
      const { loading } = proxyStates;
      const setLoading = (value = falseValue) => {
        loading.v = value;
      };
      const resolveFail = (error) => {
        setLoading();
        proxyStates.error.v = error;
        clearTimeout(retryTimer.current);
        emitOnFail(method, args, error);
      };
      if (!loading.v) {
        promiseCatch(stopPromiseObj.current.promise, (error) => {
          resolveFail(error);
          stopPromiseObj.current = usePromise();
        });
      }
      setLoading(trueValue);
      requesting.current = trueValue;
      methodInstanceLastest.current = method;
      argsLatest.current = args;
      return next().then(
        (val) => {
          setLoading();
          return val;
        },
        // Trigger retry mechanism when request fails
        (error) => {
          if (!stopManuallyError.current && (isNumber(retry) ? retryTimes.current < retry : retry(error, ...args))) {
            retryTimes.current += 1;
            const retryDelay = delayWithBackoff(backoff, retryTimes.current);
            retryTimer.current = setTimeoutFn(() => {
              eventManager.emit(RetryEventKey, newInstance(RetriableRetryEvent, AlovaEventBase.spawn(method, args), retryTimes.current, retryDelay));
              promiseCatch(send(...args), noop);
            }, retryDelay);
          } else {
            error = stopManuallyError.current || error;
            resolveFail(error);
          }
          return promiseReject(error);
        }
      ).finally(() => {
        requesting.current = falseValue;
      });
    }
  });
  const stop = () => {
    assert$1(nestedHookProvider.__proxyState("loading").v, "there is no requests being retried");
    stopManuallyError.current = newInstance(AlovaError, hookPrefix, "stop retry manually");
    if (requesting.current) {
      nestedHookProvider.abort();
    } else {
      stopPromiseObj.current.reject(stopManuallyError.current);
    }
  };
  const onRetry = (handler2) => {
    eventManager.on(RetryEventKey, (event) => handler2(event));
  };
  const onFail = (handler2) => {
    eventManager.on(FailEventKey, (event) => handler2(event));
  };
  return exposeProvider({
    ...nestedHookProvider,
    stop,
    onRetry,
    onFail
  });
};
var currentHookIndex = 0;
var actionsMap = {};
var isFrontMiddlewareContext = (context) => !!context.send;
var assert = createAssert("subscriber");
var actionDelegationMiddleware = (id) => {
  const { ref, onUnmounted } = statesHookHelper(promiseStatesHook());
  const hookIndex = ref(currentHookIndex + 1);
  if (hookIndex.current > currentHookIndex) {
    currentHookIndex += 1;
  }
  onUnmounted(() => {
    var _a;
    if ((_a = actionsMap[id]) === null || _a === void 0 ? void 0 : _a[hookIndex.current]) {
      delete actionsMap[id][hookIndex.current];
    }
  });
  return (context, next) => {
    const { abort, proxyStates, delegatingActions = {} } = context;
    const update = (newStates) => {
      for (const key in newStates) {
        proxyStates[key] && (proxyStates[key].v = newStates[key]);
      }
    };
    const hooks = actionsMap[id] = actionsMap[id] || [];
    const handler = isFrontMiddlewareContext(context) ? {
      ...delegatingActions,
      send: context.send,
      abort,
      update
    } : {
      ...delegatingActions,
      fetch: context.fetch,
      abort,
      update
    };
    hooks[hookIndex.current] = handler;
    return next();
  };
};
var accessAction = (id, onMatch, silent = false) => {
  const matched = [];
  if (typeof id === "symbol" || isString(id) || isNumber(id)) {
    actionsMap[id] && pushItem(matched, ...objectValues(actionsMap[id]));
  } else if (instanceOf(id, RegExp)) {
    forEach(filterItem(objectKeys(actionsMap), (idItem) => id.test(idItem)), (idItem) => {
      pushItem(matched, ...objectValues(actionsMap[idItem]));
    });
  }
  if (matched.length === 0 && !silent) {
    assert(false, `no handler can be matched by using \`${id.toString()}\``);
  }
  forEach(filterItem(matched, $self), onMatch);
};
export {
  accessAction,
  actionDelegationMiddleware,
  bootSilentFactory,
  createClientTokenAuthentication,
  createServerTokenAuthentication,
  dehydrateVData,
  equals,
  filterSilentMethods,
  getSilentMethod,
  isVData,
  onBeforeSilentSubmit,
  onSilentSubmitBoot,
  onSilentSubmitError,
  onSilentSubmitFail,
  onSilentSubmitSuccess,
  silentQueueMap,
  statesHookHelper,
  stringifyVData,
  updateState,
  updateStateEffect,
  useAutoRequest,
  useCaptcha,
  useFetcher,
  useForm,
  usePagination,
  useRequest,
  useRetriableRequest,
  useSQRequest,
  useSSE,
  useSerialRequest,
  useSerialWatcher,
  useUploader,
  useWatcher
};
//# sourceMappingURL=alova_client.js.map
